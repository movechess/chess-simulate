import {
  compat_exports
} from "./chunk-JY4CLL2M.js";
import {
  Board,
  Material,
  MaterialSide,
  RemainingChecks,
  SquareSet,
  defaultSetup,
  fen_exports,
  makePiece,
  n
} from "./chunk-CRQYWGHV.js";
import {
  CASTLING_SIDES,
  COLORS,
  FILE_NAMES,
  RANK_NAMES,
  ROLES,
  RULES,
  charToRole,
  defined,
  isDrop,
  isNormal,
  kingCastlesTo,
  makeSquare,
  makeUci,
  opposite,
  parseSquare,
  parseUci,
  roleToChar,
  squareFile,
  squareRank
} from "./chunk-3THGZOZQ.js";
import {
  __export
} from "./chunk-5WWUZCGV.js";

// node_modules/chessops/attacks.js
function computeRange(square2, deltas) {
  let range = SquareSet.empty();
  for (const delta of deltas) {
    const sq = square2 + delta;
    if (0 <= sq && sq < 64 && Math.abs(squareFile(square2) - squareFile(sq)) <= 2) {
      range = range.with(sq);
    }
  }
  return range;
}
function tabulate(f) {
  const table = [];
  for (let square2 = 0; square2 < 64; square2++)
    table[square2] = f(square2);
  return table;
}
var KING_ATTACKS = tabulate((sq) => computeRange(sq, [-9, -8, -7, -1, 1, 7, 8, 9]));
var KNIGHT_ATTACKS = tabulate((sq) => computeRange(sq, [-17, -15, -10, -6, 6, 10, 15, 17]));
var PAWN_ATTACKS = {
  white: tabulate((sq) => computeRange(sq, [7, 9])),
  black: tabulate((sq) => computeRange(sq, [-7, -9]))
};
function kingAttacks(square2) {
  return KING_ATTACKS[square2];
}
function knightAttacks(square2) {
  return KNIGHT_ATTACKS[square2];
}
function pawnAttacks(color, square2) {
  return PAWN_ATTACKS[color][square2];
}
var FILE_RANGE = tabulate((sq) => SquareSet.fromFile(squareFile(sq)).without(sq));
var RANK_RANGE = tabulate((sq) => SquareSet.fromRank(squareRank(sq)).without(sq));
var DIAG_RANGE = tabulate((sq) => {
  const diag = new SquareSet(134480385, 2151686160);
  const shift = 8 * (squareRank(sq) - squareFile(sq));
  return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);
});
var ANTI_DIAG_RANGE = tabulate((sq) => {
  const diag = new SquareSet(270549120, 16909320);
  const shift = 8 * (squareRank(sq) + squareFile(sq) - 7);
  return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);
});
function hyperbola(bit, range, occupied) {
  let forward = occupied.intersect(range);
  let reverse = forward.bswap64();
  forward = forward.minus64(bit);
  reverse = reverse.minus64(bit.bswap64());
  return forward.xor(reverse.bswap64()).intersect(range);
}
function fileAttacks(square2, occupied) {
  return hyperbola(SquareSet.fromSquare(square2), FILE_RANGE[square2], occupied);
}
function rankAttacks(square2, occupied) {
  const range = RANK_RANGE[square2];
  let forward = occupied.intersect(range);
  let reverse = forward.rbit64();
  forward = forward.minus64(SquareSet.fromSquare(square2));
  reverse = reverse.minus64(SquareSet.fromSquare(63 - square2));
  return forward.xor(reverse.rbit64()).intersect(range);
}
function bishopAttacks(square2, occupied) {
  const bit = SquareSet.fromSquare(square2);
  return hyperbola(bit, DIAG_RANGE[square2], occupied).xor(hyperbola(bit, ANTI_DIAG_RANGE[square2], occupied));
}
function rookAttacks(square2, occupied) {
  return fileAttacks(square2, occupied).xor(rankAttacks(square2, occupied));
}
function queenAttacks(square2, occupied) {
  return bishopAttacks(square2, occupied).xor(rookAttacks(square2, occupied));
}
function attacks(piece2, square2, occupied) {
  switch (piece2.role) {
    case "pawn":
      return pawnAttacks(piece2.color, square2);
    case "knight":
      return knightAttacks(square2);
    case "bishop":
      return bishopAttacks(square2, occupied);
    case "rook":
      return rookAttacks(square2, occupied);
    case "queen":
      return queenAttacks(square2, occupied);
    case "king":
      return kingAttacks(square2);
  }
}
function ray(a, b) {
  const other = SquareSet.fromSquare(b);
  if (RANK_RANGE[a].intersects(other))
    return RANK_RANGE[a].with(a);
  if (ANTI_DIAG_RANGE[a].intersects(other))
    return ANTI_DIAG_RANGE[a].with(a);
  if (DIAG_RANGE[a].intersects(other))
    return DIAG_RANGE[a].with(a);
  if (FILE_RANGE[a].intersects(other))
    return FILE_RANGE[a].with(a);
  return SquareSet.empty();
}
function between(a, b) {
  return ray(a, b).intersect(SquareSet.full().shl64(a).xor(SquareSet.full().shl64(b))).withoutFirst();
}

// node_modules/chessops/chess.js
var IllegalSetup;
(function(IllegalSetup2) {
  IllegalSetup2["Empty"] = "ERR_EMPTY";
  IllegalSetup2["OppositeCheck"] = "ERR_OPPOSITE_CHECK";
  IllegalSetup2["ImpossibleCheck"] = "ERR_IMPOSSIBLE_CHECK";
  IllegalSetup2["PawnsOnBackrank"] = "ERR_PAWNS_ON_BACKRANK";
  IllegalSetup2["Kings"] = "ERR_KINGS";
  IllegalSetup2["Variant"] = "ERR_VARIANT";
})(IllegalSetup || (IllegalSetup = {}));
var PositionError = class extends Error {
};
function attacksTo(square2, attacker, board2, occupied) {
  return board2[attacker].intersect(rookAttacks(square2, occupied).intersect(board2.rooksAndQueens()).union(bishopAttacks(square2, occupied).intersect(board2.bishopsAndQueens())).union(knightAttacks(square2).intersect(board2.knight)).union(kingAttacks(square2).intersect(board2.king)).union(pawnAttacks(opposite(attacker), square2).intersect(board2.pawn)));
}
function rookCastlesTo(color, side) {
  return color === "white" ? side === "a" ? 3 : 5 : side === "a" ? 59 : 61;
}
var Castles = class _Castles {
  constructor() {
  }
  static default() {
    const castles = new _Castles();
    castles.unmovedRooks = SquareSet.corners();
    castles.rook = {
      white: { a: 0, h: 7 },
      black: { a: 56, h: 63 }
    };
    castles.path = {
      white: { a: new SquareSet(14, 0), h: new SquareSet(96, 0) },
      black: { a: new SquareSet(0, 234881024), h: new SquareSet(0, 1610612736) }
    };
    return castles;
  }
  static empty() {
    const castles = new _Castles();
    castles.unmovedRooks = SquareSet.empty();
    castles.rook = {
      white: { a: void 0, h: void 0 },
      black: { a: void 0, h: void 0 }
    };
    castles.path = {
      white: { a: SquareSet.empty(), h: SquareSet.empty() },
      black: { a: SquareSet.empty(), h: SquareSet.empty() }
    };
    return castles;
  }
  clone() {
    const castles = new _Castles();
    castles.unmovedRooks = this.unmovedRooks;
    castles.rook = {
      white: { a: this.rook.white.a, h: this.rook.white.h },
      black: { a: this.rook.black.a, h: this.rook.black.h }
    };
    castles.path = {
      white: { a: this.path.white.a, h: this.path.white.h },
      black: { a: this.path.black.a, h: this.path.black.h }
    };
    return castles;
  }
  add(color, side, king, rook) {
    const kingTo = kingCastlesTo(color, side);
    const rookTo = rookCastlesTo(color, side);
    this.unmovedRooks = this.unmovedRooks.with(rook);
    this.rook[color][side] = rook;
    this.path[color][side] = between(rook, rookTo).with(rookTo).union(between(king, kingTo).with(kingTo)).without(king).without(rook);
  }
  static fromSetup(setup) {
    const castles = _Castles.empty();
    const rooks = setup.unmovedRooks.intersect(setup.board.rook);
    for (const color of COLORS) {
      const backrank = SquareSet.backrank(color);
      const king = setup.board.kingOf(color);
      if (!defined(king) || !backrank.has(king))
        continue;
      const side = rooks.intersect(setup.board[color]).intersect(backrank);
      const aSide = side.first();
      if (defined(aSide) && aSide < king)
        castles.add(color, "a", king, aSide);
      const hSide = side.last();
      if (defined(hSide) && king < hSide)
        castles.add(color, "h", king, hSide);
    }
    return castles;
  }
  discardRook(square2) {
    if (this.unmovedRooks.has(square2)) {
      this.unmovedRooks = this.unmovedRooks.without(square2);
      for (const color of COLORS) {
        for (const side of CASTLING_SIDES) {
          if (this.rook[color][side] === square2)
            this.rook[color][side] = void 0;
        }
      }
    }
  }
  discardSide(color) {
    this.unmovedRooks = this.unmovedRooks.diff(SquareSet.backrank(color));
    this.rook[color].a = void 0;
    this.rook[color].h = void 0;
  }
};
var Position = class {
  constructor(rules) {
    this.rules = rules;
  }
  kingAttackers(square2, attacker, occupied) {
    return attacksTo(square2, attacker, this.board, occupied);
  }
  dropDests(_ctx) {
    return SquareSet.empty();
  }
  playCaptureAt(square2, captured) {
    this.halfmoves = 0;
    if (captured.role === "rook")
      this.castles.discardRook(square2);
    if (this.pockets)
      this.pockets[opposite(captured.color)][captured.role]++;
  }
  ctx() {
    const variantEnd = this.isVariantEnd();
    const king = this.board.kingOf(this.turn);
    if (!defined(king))
      return { king, blockers: SquareSet.empty(), checkers: SquareSet.empty(), variantEnd, mustCapture: false };
    const snipers = rookAttacks(king, SquareSet.empty()).intersect(this.board.rooksAndQueens()).union(bishopAttacks(king, SquareSet.empty()).intersect(this.board.bishopsAndQueens())).intersect(this.board[opposite(this.turn)]);
    let blockers = SquareSet.empty();
    for (const sniper of snipers) {
      const b = between(king, sniper).intersect(this.board.occupied);
      if (!b.moreThanOne())
        blockers = blockers.union(b);
    }
    const checkers = this.kingAttackers(king, opposite(this.turn), this.board.occupied);
    return {
      king,
      blockers,
      checkers,
      variantEnd,
      mustCapture: false
    };
  }
  // The following should be identical in all subclasses
  clone() {
    var _a, _b;
    const pos = new this.constructor();
    pos.board = this.board.clone();
    pos.pockets = (_a = this.pockets) === null || _a === void 0 ? void 0 : _a.clone();
    pos.turn = this.turn;
    pos.castles = this.castles.clone();
    pos.epSquare = this.epSquare;
    pos.remainingChecks = (_b = this.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone();
    pos.halfmoves = this.halfmoves;
    pos.fullmoves = this.fullmoves;
    return pos;
  }
  equalsIgnoreMoves(other) {
    var _a, _b;
    return this.rules === other.rules && (this.pockets ? this.board.equals(other.board) : this.board.equalsIgnorePromoted(other.board)) && (other.pockets && ((_a = this.pockets) === null || _a === void 0 ? void 0 : _a.equals(other.pockets)) || !this.pockets && !other.pockets) && this.turn === other.turn && this.castles.unmovedRooks.equals(other.castles.unmovedRooks) && this.legalEpSquare() === other.legalEpSquare() && (other.remainingChecks && ((_b = this.remainingChecks) === null || _b === void 0 ? void 0 : _b.equals(other.remainingChecks)) || !this.remainingChecks && !other.remainingChecks);
  }
  toSetup() {
    var _a, _b;
    return {
      board: this.board.clone(),
      pockets: (_a = this.pockets) === null || _a === void 0 ? void 0 : _a.clone(),
      turn: this.turn,
      unmovedRooks: this.castles.unmovedRooks,
      epSquare: this.legalEpSquare(),
      remainingChecks: (_b = this.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone(),
      halfmoves: Math.min(this.halfmoves, 150),
      fullmoves: Math.min(Math.max(this.fullmoves, 1), 9999)
    };
  }
  isInsufficientMaterial() {
    return COLORS.every((color) => this.hasInsufficientMaterial(color));
  }
  hasDests(ctx) {
    ctx = ctx || this.ctx();
    for (const square2 of this.board[this.turn]) {
      if (this.dests(square2, ctx).nonEmpty())
        return true;
    }
    return this.dropDests(ctx).nonEmpty();
  }
  isLegal(move, ctx) {
    if (isDrop(move)) {
      if (!this.pockets || this.pockets[this.turn][move.role] <= 0)
        return false;
      if (move.role === "pawn" && SquareSet.backranks().has(move.to))
        return false;
      return this.dropDests(ctx).has(move.to);
    } else {
      if (move.promotion === "pawn")
        return false;
      if (move.promotion === "king" && this.rules !== "antichess")
        return false;
      if (!!move.promotion !== (this.board.pawn.has(move.from) && SquareSet.backranks().has(move.to)))
        return false;
      const dests2 = this.dests(move.from, ctx);
      return dests2.has(move.to) || dests2.has(this.normalizeMove(move).to);
    }
  }
  isCheck() {
    const king = this.board.kingOf(this.turn);
    return defined(king) && this.kingAttackers(king, opposite(this.turn), this.board.occupied).nonEmpty();
  }
  isEnd(ctx) {
    if (ctx ? ctx.variantEnd : this.isVariantEnd())
      return true;
    return this.isInsufficientMaterial() || !this.hasDests(ctx);
  }
  isCheckmate(ctx) {
    ctx = ctx || this.ctx();
    return !ctx.variantEnd && ctx.checkers.nonEmpty() && !this.hasDests(ctx);
  }
  isStalemate(ctx) {
    ctx = ctx || this.ctx();
    return !ctx.variantEnd && ctx.checkers.isEmpty() && !this.hasDests(ctx);
  }
  outcome(ctx) {
    const variantOutcome = this.variantOutcome(ctx);
    if (variantOutcome)
      return variantOutcome;
    ctx = ctx || this.ctx();
    if (this.isCheckmate(ctx))
      return { winner: opposite(this.turn) };
    else if (this.isInsufficientMaterial() || this.isStalemate(ctx))
      return { winner: void 0 };
    else
      return;
  }
  allDests(ctx) {
    ctx = ctx || this.ctx();
    const d = /* @__PURE__ */ new Map();
    if (ctx.variantEnd)
      return d;
    for (const square2 of this.board[this.turn]) {
      d.set(square2, this.dests(square2, ctx));
    }
    return d;
  }
  castlingSide(move) {
    if (isDrop(move))
      return;
    const delta = move.to - move.from;
    if (Math.abs(delta) !== 2 && !this.board[this.turn].has(move.to))
      return;
    if (!this.board.king.has(move.from))
      return;
    return delta > 0 ? "h" : "a";
  }
  normalizeMove(move) {
    const castlingSide = this.castlingSide(move);
    if (!castlingSide)
      return move;
    const rookFrom = this.castles.rook[this.turn][castlingSide];
    return {
      from: move.from,
      to: defined(rookFrom) ? rookFrom : move.to
    };
  }
  play(move) {
    const turn = this.turn;
    const epSquare = this.epSquare;
    const castlingSide = this.castlingSide(move);
    this.epSquare = void 0;
    this.halfmoves += 1;
    if (turn === "black")
      this.fullmoves += 1;
    this.turn = opposite(turn);
    if (isDrop(move)) {
      this.board.set(move.to, { role: move.role, color: turn });
      if (this.pockets)
        this.pockets[turn][move.role]--;
      if (move.role === "pawn")
        this.halfmoves = 0;
    } else {
      const piece2 = this.board.take(move.from);
      if (!piece2)
        return;
      let epCapture;
      if (piece2.role === "pawn") {
        this.halfmoves = 0;
        if (move.to === epSquare) {
          epCapture = this.board.take(move.to + (turn === "white" ? -8 : 8));
        }
        const delta = move.from - move.to;
        if (Math.abs(delta) === 16 && 8 <= move.from && move.from <= 55) {
          this.epSquare = move.from + move.to >> 1;
        }
        if (move.promotion) {
          piece2.role = move.promotion;
          piece2.promoted = true;
        }
      } else if (piece2.role === "rook") {
        this.castles.discardRook(move.from);
      } else if (piece2.role === "king") {
        if (castlingSide) {
          const rookFrom = this.castles.rook[turn][castlingSide];
          if (defined(rookFrom)) {
            const rook = this.board.take(rookFrom);
            this.board.set(kingCastlesTo(turn, castlingSide), piece2);
            if (rook)
              this.board.set(rookCastlesTo(turn, castlingSide), rook);
          }
        }
        this.castles.discardSide(turn);
      }
      if (!castlingSide) {
        const capture = this.board.set(move.to, piece2) || epCapture;
        if (capture)
          this.playCaptureAt(move.to, capture);
      }
    }
    if (this.remainingChecks) {
      if (this.isCheck())
        this.remainingChecks[turn] = Math.max(this.remainingChecks[turn] - 1, 0);
    }
  }
  legalEpSquare(ctx) {
    if (!defined(this.epSquare))
      return;
    ctx = ctx || this.ctx();
    const ourPawns = this.board.pieces(this.turn, "pawn");
    const candidates = ourPawns.intersect(pawnAttacks(opposite(this.turn), this.epSquare));
    for (const candidate of candidates) {
      if (this.dests(candidate, ctx).has(this.epSquare))
        return this.epSquare;
    }
    return;
  }
};
var Chess = class extends Position {
  constructor(rules) {
    super(rules || "chess");
  }
  static default() {
    const pos = new this();
    pos.board = Board.default();
    pos.pockets = void 0;
    pos.turn = "white";
    pos.castles = Castles.default();
    pos.epSquare = void 0;
    pos.remainingChecks = void 0;
    pos.halfmoves = 0;
    pos.fullmoves = 1;
    return pos;
  }
  static fromSetup(setup, opts) {
    const pos = new this();
    pos.board = setup.board.clone();
    pos.pockets = void 0;
    pos.turn = setup.turn;
    pos.castles = Castles.fromSetup(setup);
    pos.epSquare = pos.validEpSquare(setup.epSquare);
    pos.remainingChecks = void 0;
    pos.halfmoves = setup.halfmoves;
    pos.fullmoves = setup.fullmoves;
    return pos.validate(opts).map((_) => pos);
  }
  clone() {
    return super.clone();
  }
  validate(opts) {
    if (this.board.occupied.isEmpty())
      return n.err(new PositionError(IllegalSetup.Empty));
    if (this.board.king.size() !== 2)
      return n.err(new PositionError(IllegalSetup.Kings));
    if (!defined(this.board.kingOf(this.turn)))
      return n.err(new PositionError(IllegalSetup.Kings));
    const otherKing = this.board.kingOf(opposite(this.turn));
    if (!defined(otherKing))
      return n.err(new PositionError(IllegalSetup.Kings));
    if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty())
      return n.err(new PositionError(IllegalSetup.OppositeCheck));
    if (SquareSet.backranks().intersects(this.board.pawn))
      return n.err(new PositionError(IllegalSetup.PawnsOnBackrank));
    return (opts === null || opts === void 0 ? void 0 : opts.ignoreImpossibleCheck) ? n.ok(void 0) : this.validateCheckers();
  }
  validateCheckers() {
    const ourKing = this.board.kingOf(this.turn);
    if (defined(ourKing)) {
      const checkers = this.kingAttackers(ourKing, opposite(this.turn), this.board.occupied);
      if (checkers.nonEmpty()) {
        if (defined(this.epSquare)) {
          const pushedTo = this.epSquare ^ 8;
          const pushedFrom = this.epSquare ^ 24;
          if (checkers.moreThanOne() || checkers.first() != pushedTo && this.kingAttackers(ourKing, opposite(this.turn), this.board.occupied.without(pushedTo).with(pushedFrom)).nonEmpty())
            return n.err(new PositionError(IllegalSetup.ImpossibleCheck));
        } else {
          if (checkers.size() > 2 || checkers.size() === 2 && ray(checkers.first(), checkers.last()).has(ourKing))
            return n.err(new PositionError(IllegalSetup.ImpossibleCheck));
        }
      }
    }
    return n.ok(void 0);
  }
  validEpSquare(square2) {
    if (!defined(square2))
      return;
    const epRank = this.turn === "white" ? 5 : 2;
    const forward = this.turn === "white" ? 8 : -8;
    if (squareRank(square2) !== epRank)
      return;
    if (this.board.occupied.has(square2 + forward))
      return;
    const pawn = square2 - forward;
    if (!this.board.pawn.has(pawn) || !this.board[opposite(this.turn)].has(pawn))
      return;
    return square2;
  }
  castlingDest(side, ctx) {
    if (!defined(ctx.king) || ctx.checkers.nonEmpty())
      return SquareSet.empty();
    const rook = this.castles.rook[this.turn][side];
    if (!defined(rook))
      return SquareSet.empty();
    if (this.castles.path[this.turn][side].intersects(this.board.occupied))
      return SquareSet.empty();
    const kingTo = kingCastlesTo(this.turn, side);
    const kingPath = between(ctx.king, kingTo);
    const occ = this.board.occupied.without(ctx.king);
    for (const sq of kingPath) {
      if (this.kingAttackers(sq, opposite(this.turn), occ).nonEmpty())
        return SquareSet.empty();
    }
    const rookTo = rookCastlesTo(this.turn, side);
    const after = this.board.occupied.toggle(ctx.king).toggle(rook).toggle(rookTo);
    if (this.kingAttackers(kingTo, opposite(this.turn), after).nonEmpty())
      return SquareSet.empty();
    return SquareSet.fromSquare(rook);
  }
  canCaptureEp(pawn, ctx) {
    if (!defined(this.epSquare))
      return false;
    if (!pawnAttacks(this.turn, pawn).has(this.epSquare))
      return false;
    if (!defined(ctx.king))
      return true;
    const captured = this.epSquare + (this.turn === "white" ? -8 : 8);
    const occupied = this.board.occupied.toggle(pawn).toggle(this.epSquare).toggle(captured);
    return !this.kingAttackers(ctx.king, opposite(this.turn), occupied).intersects(occupied);
  }
  pseudoDests(square2, ctx) {
    if (ctx.variantEnd)
      return SquareSet.empty();
    const piece2 = this.board.get(square2);
    if (!piece2 || piece2.color !== this.turn)
      return SquareSet.empty();
    let pseudo = attacks(piece2, square2, this.board.occupied);
    if (piece2.role === "pawn") {
      let captureTargets = this.board[opposite(this.turn)];
      if (defined(this.epSquare))
        captureTargets = captureTargets.with(this.epSquare);
      pseudo = pseudo.intersect(captureTargets);
      const delta = this.turn === "white" ? 8 : -8;
      const step = square2 + delta;
      if (0 <= step && step < 64 && !this.board.occupied.has(step)) {
        pseudo = pseudo.with(step);
        const canDoubleStep = this.turn === "white" ? square2 < 16 : square2 >= 64 - 16;
        const doubleStep = step + delta;
        if (canDoubleStep && !this.board.occupied.has(doubleStep)) {
          pseudo = pseudo.with(doubleStep);
        }
      }
      return pseudo;
    } else {
      pseudo = pseudo.diff(this.board[this.turn]);
    }
    if (square2 === ctx.king)
      return pseudo.union(this.castlingDest("a", ctx)).union(this.castlingDest("h", ctx));
    else
      return pseudo;
  }
  dests(square2, ctx) {
    ctx = ctx || this.ctx();
    if (ctx.variantEnd)
      return SquareSet.empty();
    const piece2 = this.board.get(square2);
    if (!piece2 || piece2.color !== this.turn)
      return SquareSet.empty();
    let pseudo, legal;
    if (piece2.role === "pawn") {
      pseudo = pawnAttacks(this.turn, square2).intersect(this.board[opposite(this.turn)]);
      const delta = this.turn === "white" ? 8 : -8;
      const step = square2 + delta;
      if (0 <= step && step < 64 && !this.board.occupied.has(step)) {
        pseudo = pseudo.with(step);
        const canDoubleStep = this.turn === "white" ? square2 < 16 : square2 >= 64 - 16;
        const doubleStep = step + delta;
        if (canDoubleStep && !this.board.occupied.has(doubleStep)) {
          pseudo = pseudo.with(doubleStep);
        }
      }
      if (defined(this.epSquare) && this.canCaptureEp(square2, ctx)) {
        const pawn = this.epSquare - delta;
        if (ctx.checkers.isEmpty() || ctx.checkers.singleSquare() === pawn) {
          legal = SquareSet.fromSquare(this.epSquare);
        }
      }
    } else if (piece2.role === "bishop")
      pseudo = bishopAttacks(square2, this.board.occupied);
    else if (piece2.role === "knight")
      pseudo = knightAttacks(square2);
    else if (piece2.role === "rook")
      pseudo = rookAttacks(square2, this.board.occupied);
    else if (piece2.role === "queen")
      pseudo = queenAttacks(square2, this.board.occupied);
    else
      pseudo = kingAttacks(square2);
    pseudo = pseudo.diff(this.board[this.turn]);
    if (defined(ctx.king)) {
      if (piece2.role === "king") {
        const occ = this.board.occupied.without(square2);
        for (const to of pseudo) {
          if (this.kingAttackers(to, opposite(this.turn), occ).nonEmpty())
            pseudo = pseudo.without(to);
        }
        return pseudo.union(this.castlingDest("a", ctx)).union(this.castlingDest("h", ctx));
      }
      if (ctx.checkers.nonEmpty()) {
        const checker = ctx.checkers.singleSquare();
        if (!defined(checker))
          return SquareSet.empty();
        pseudo = pseudo.intersect(between(checker, ctx.king).with(checker));
      }
      if (ctx.blockers.has(square2))
        pseudo = pseudo.intersect(ray(square2, ctx.king));
    }
    if (legal)
      pseudo = pseudo.union(legal);
    return pseudo;
  }
  isVariantEnd() {
    return false;
  }
  variantOutcome(_ctx) {
    return;
  }
  hasInsufficientMaterial(color) {
    if (this.board[color].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty())
      return false;
    if (this.board[color].intersects(this.board.knight)) {
      return this.board[color].size() <= 2 && this.board[opposite(color)].diff(this.board.king).diff(this.board.queen).isEmpty();
    }
    if (this.board[color].intersects(this.board.bishop)) {
      const sameColor = !this.board.bishop.intersects(SquareSet.darkSquares()) || !this.board.bishop.intersects(SquareSet.lightSquares());
      return sameColor && this.board.pawn.isEmpty() && this.board.knight.isEmpty();
    }
    return true;
  }
};

// node_modules/chessops/debug.js
var debug_exports = {};
__export(debug_exports, {
  board: () => board,
  dests: () => dests,
  perft: () => perft,
  piece: () => piece,
  square: () => square,
  squareSet: () => squareSet
});
function squareSet(squares) {
  const r = [];
  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const square2 = x + y * 8;
      r.push(squares.has(square2) ? "1" : ".");
      r.push(x < 7 ? " " : "\n");
    }
  }
  return r.join("");
}
function piece(piece2) {
  return makePiece(piece2);
}
function board(board2) {
  const r = [];
  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const square2 = x + y * 8;
      const p = board2.get(square2);
      const col = p ? piece(p) : ".";
      r.push(col);
      r.push(x < 7 ? col.length < 2 ? " " : "" : "\n");
    }
  }
  return r.join("");
}
function square(sq) {
  return makeSquare(sq);
}
function dests(dests2) {
  const lines = [];
  for (const [from, to] of dests2) {
    lines.push(`${makeSquare(from)}: ${Array.from(to, square).join(" ")}`);
  }
  return lines.join("\n");
}
function perft(pos, depth, log = false) {
  if (depth < 1)
    return 1;
  const promotionRoles = ["queen", "knight", "rook", "bishop"];
  if (pos.rules === "antichess")
    promotionRoles.push("king");
  const ctx = pos.ctx();
  const dropDests = pos.dropDests(ctx);
  if (!log && depth === 1 && dropDests.isEmpty()) {
    let nodes = 0;
    for (const [from, to] of pos.allDests(ctx)) {
      nodes += to.size();
      if (pos.board.pawn.has(from)) {
        const backrank = SquareSet.backrank(opposite(pos.turn));
        nodes += to.intersect(backrank).size() * (promotionRoles.length - 1);
      }
    }
    return nodes;
  } else {
    let nodes = 0;
    for (const [from, dests2] of pos.allDests(ctx)) {
      const promotions = squareRank(from) === (pos.turn === "white" ? 6 : 1) && pos.board.pawn.has(from) ? promotionRoles : [void 0];
      for (const to of dests2) {
        for (const promotion of promotions) {
          const child = pos.clone();
          const move = { from, to, promotion };
          child.play(move);
          const children = perft(child, depth - 1, false);
          if (log)
            console.log(makeUci(move), children);
          nodes += children;
        }
      }
    }
    if (pos.pockets) {
      for (const role of ROLES) {
        if (pos.pockets[pos.turn][role] > 0) {
          for (const to of role === "pawn" ? dropDests.diff(SquareSet.backranks()) : dropDests) {
            const child = pos.clone();
            const move = { role, to };
            child.play(move);
            const children = perft(child, depth - 1, false);
            if (log)
              console.log(makeUci(move), children);
            nodes += children;
          }
        }
      }
    }
    return nodes;
  }
}

// node_modules/chessops/hash.js
var hash_exports = {};
__export(hash_exports, {
  fxhash32: () => fxhash32,
  hashBoard: () => hashBoard,
  hashMaterial: () => hashMaterial,
  hashMaterialSide: () => hashMaterialSide,
  hashRemainingChecks: () => hashRemainingChecks,
  hashSetup: () => hashSetup
});
function rol32(n2, left) {
  return n2 << left | n2 >>> 32 - left;
}
function fxhash32(word, state = 0) {
  return Math.imul(rol32(state, 5) ^ word, 2654435769);
}
function hashBoard(board2, state = 0) {
  state = fxhash32(board2.white.lo, fxhash32(board2.white.hi, state));
  for (const role of ROLES)
    state = fxhash32(board2[role].lo, fxhash32(board2[role].hi, state));
  return state;
}
function hashMaterialSide(side, state = 0) {
  for (const role of ROLES)
    state = fxhash32(side[role], state);
  return state;
}
function hashMaterial(material, state = 0) {
  for (const color of COLORS)
    state = hashMaterialSide(material[color], state);
  return state;
}
function hashRemainingChecks(checks, state = 0) {
  return fxhash32(checks.white, fxhash32(checks.black, state));
}
function hashSetup(setup, state = 0) {
  state = hashBoard(setup.board, state);
  if (setup.pockets)
    state = hashMaterial(setup.pockets, state);
  if (setup.turn === "white")
    state = fxhash32(1, state);
  state = fxhash32(setup.unmovedRooks.lo, fxhash32(setup.unmovedRooks.hi, state));
  if (defined(setup.epSquare))
    state = fxhash32(setup.epSquare, state);
  if (setup.remainingChecks)
    state = hashRemainingChecks(setup.remainingChecks, state);
  return state;
}

// node_modules/chessops/san.js
var san_exports = {};
__export(san_exports, {
  makeSan: () => makeSan,
  makeSanAndPlay: () => makeSanAndPlay,
  makeSanVariation: () => makeSanVariation,
  parseSan: () => parseSan
});
function makeSanWithoutSuffix(pos, move) {
  let san = "";
  if (isDrop(move)) {
    if (move.role !== "pawn")
      san = roleToChar(move.role).toUpperCase();
    san += "@" + makeSquare(move.to);
  } else {
    const role = pos.board.getRole(move.from);
    if (!role)
      return "--";
    if (role === "king" && (pos.board[pos.turn].has(move.to) || Math.abs(move.to - move.from) === 2)) {
      san = move.to > move.from ? "O-O" : "O-O-O";
    } else {
      const capture = pos.board.occupied.has(move.to) || role === "pawn" && squareFile(move.from) !== squareFile(move.to);
      if (role !== "pawn") {
        san = roleToChar(role).toUpperCase();
        let others;
        if (role === "king")
          others = kingAttacks(move.to).intersect(pos.board.king);
        else if (role === "queen")
          others = queenAttacks(move.to, pos.board.occupied).intersect(pos.board.queen);
        else if (role === "rook")
          others = rookAttacks(move.to, pos.board.occupied).intersect(pos.board.rook);
        else if (role === "bishop")
          others = bishopAttacks(move.to, pos.board.occupied).intersect(pos.board.bishop);
        else
          others = knightAttacks(move.to).intersect(pos.board.knight);
        others = others.intersect(pos.board[pos.turn]).without(move.from);
        if (others.nonEmpty()) {
          const ctx = pos.ctx();
          for (const from of others) {
            if (!pos.dests(from, ctx).has(move.to))
              others = others.without(from);
          }
          if (others.nonEmpty()) {
            let row = false;
            let column = others.intersects(SquareSet.fromRank(squareRank(move.from)));
            if (others.intersects(SquareSet.fromFile(squareFile(move.from))))
              row = true;
            else
              column = true;
            if (column)
              san += FILE_NAMES[squareFile(move.from)];
            if (row)
              san += RANK_NAMES[squareRank(move.from)];
          }
        }
      } else if (capture)
        san = FILE_NAMES[squareFile(move.from)];
      if (capture)
        san += "x";
      san += makeSquare(move.to);
      if (move.promotion)
        san += "=" + roleToChar(move.promotion).toUpperCase();
    }
  }
  return san;
}
function makeSanAndPlay(pos, move) {
  var _a;
  const san = makeSanWithoutSuffix(pos, move);
  pos.play(move);
  if ((_a = pos.outcome()) === null || _a === void 0 ? void 0 : _a.winner)
    return san + "#";
  if (pos.isCheck())
    return san + "+";
  return san;
}
function makeSanVariation(pos, variation) {
  var _a;
  pos = pos.clone();
  const line = [];
  for (let i = 0; i < variation.length; i++) {
    if (i !== 0)
      line.push(" ");
    if (pos.turn === "white")
      line.push(pos.fullmoves, ". ");
    else if (i === 0)
      line.push(pos.fullmoves, "... ");
    const san = makeSanWithoutSuffix(pos, variation[i]);
    pos.play(variation[i]);
    line.push(san);
    if (san === "--")
      return line.join("");
    if (i === variation.length - 1 && ((_a = pos.outcome()) === null || _a === void 0 ? void 0 : _a.winner))
      line.push("#");
    else if (pos.isCheck())
      line.push("+");
  }
  return line.join("");
}
function makeSan(pos, move) {
  return makeSanAndPlay(pos.clone(), move);
}
function parseSan(pos, san) {
  const ctx = pos.ctx();
  let castlingSide;
  if (san === "O-O" || san === "O-O+" || san === "O-O#")
    castlingSide = "h";
  else if (san === "O-O-O" || san === "O-O-O+" || san === "O-O-O#")
    castlingSide = "a";
  if (castlingSide) {
    const rook = pos.castles.rook[pos.turn][castlingSide];
    if (!defined(ctx.king) || !defined(rook) || !pos.dests(ctx.king, ctx).has(rook))
      return;
    return {
      from: ctx.king,
      to: rook
    };
  }
  const match = san.match(/^([NBRQK])?([a-h])?([1-8])?[-x]?([a-h][1-8])(?:=?([nbrqkNBRQK]))?[+#]?$/);
  if (!match) {
    const match2 = san.match(/^([pnbrqkPNBRQK])?@([a-h][1-8])[+#]?$/);
    if (!match2)
      return;
    const move = {
      role: charToRole(match2[1]) || "pawn",
      to: parseSquare(match2[2])
    };
    return pos.isLegal(move, ctx) ? move : void 0;
  }
  const role = charToRole(match[1]) || "pawn";
  const to = parseSquare(match[4]);
  const promotion = charToRole(match[5]);
  if (!!promotion !== (role === "pawn" && SquareSet.backranks().has(to)))
    return;
  if (promotion === "king" && pos.rules !== "antichess")
    return;
  let candidates = pos.board.pieces(pos.turn, role);
  if (match[2])
    candidates = candidates.intersect(SquareSet.fromFile(match[2].charCodeAt(0) - "a".charCodeAt(0)));
  if (match[3])
    candidates = candidates.intersect(SquareSet.fromRank(match[3].charCodeAt(0) - "1".charCodeAt(0)));
  const pawnAdvance = role === "pawn" ? SquareSet.fromFile(squareFile(to)) : SquareSet.empty();
  candidates = candidates.intersect(pawnAdvance.union(attacks({ color: opposite(pos.turn), role }, to, pos.board.occupied)));
  let from;
  for (const candidate of candidates) {
    if (pos.dests(candidate, ctx).has(to)) {
      if (defined(from))
        return;
      from = candidate;
    }
  }
  if (!defined(from))
    return;
  return {
    from,
    to,
    promotion
  };
}

// node_modules/chessops/transform.js
var transform_exports = {};
__export(transform_exports, {
  flipDiagonal: () => flipDiagonal,
  flipHorizontal: () => flipHorizontal,
  flipVertical: () => flipVertical,
  rotate180: () => rotate180,
  transformBoard: () => transformBoard,
  transformSetup: () => transformSetup
});
function flipVertical(s) {
  return s.bswap64();
}
function flipHorizontal(s) {
  const k1 = new SquareSet(1431655765, 1431655765);
  const k2 = new SquareSet(858993459, 858993459);
  const k4 = new SquareSet(252645135, 252645135);
  s = s.shr64(1).intersect(k1).union(s.intersect(k1).shl64(1));
  s = s.shr64(2).intersect(k2).union(s.intersect(k2).shl64(2));
  s = s.shr64(4).intersect(k4).union(s.intersect(k4).shl64(4));
  return s;
}
function flipDiagonal(s) {
  let t = s.xor(s.shl64(28)).intersect(new SquareSet(0, 252645135));
  s = s.xor(t.xor(t.shr64(28)));
  t = s.xor(s.shl64(14)).intersect(new SquareSet(858980352, 858980352));
  s = s.xor(t.xor(t.shr64(14)));
  t = s.xor(s.shl64(7)).intersect(new SquareSet(1426085120, 1426085120));
  s = s.xor(t.xor(t.shr64(7)));
  return s;
}
function rotate180(s) {
  return s.rbit64();
}
function transformBoard(board2, f) {
  const b = Board.empty();
  b.occupied = f(board2.occupied);
  b.promoted = f(board2.promoted);
  for (const color of COLORS)
    b[color] = f(board2[color]);
  for (const role of ROLES)
    b[role] = f(board2[role]);
  return b;
}
function transformSetup(setup, f) {
  var _a, _b;
  return {
    board: transformBoard(setup.board, f),
    pockets: (_a = setup.pockets) === null || _a === void 0 ? void 0 : _a.clone(),
    turn: setup.turn,
    unmovedRooks: f(setup.unmovedRooks),
    epSquare: defined(setup.epSquare) ? f(SquareSet.fromSquare(setup.epSquare)).first() : void 0,
    remainingChecks: (_b = setup.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone(),
    halfmoves: setup.halfmoves,
    fullmoves: setup.fullmoves
  };
}

// node_modules/chessops/variant.js
var variant_exports = {};
__export(variant_exports, {
  Antichess: () => Antichess,
  Atomic: () => Atomic,
  Castles: () => Castles,
  Chess: () => Chess,
  Crazyhouse: () => Crazyhouse,
  Horde: () => Horde,
  IllegalSetup: () => IllegalSetup,
  KingOfTheHill: () => KingOfTheHill,
  Position: () => Position,
  PositionError: () => PositionError,
  RacingKings: () => RacingKings,
  ThreeCheck: () => ThreeCheck,
  defaultPosition: () => defaultPosition,
  setupPosition: () => setupPosition
});
var Crazyhouse = class extends Chess {
  constructor() {
    super("crazyhouse");
  }
  static default() {
    const pos = super.default();
    pos.pockets = Material.empty();
    return pos;
  }
  static fromSetup(setup, opts) {
    return super.fromSetup(setup, opts).map((pos) => {
      pos.pockets = setup.pockets ? setup.pockets.clone() : Material.empty();
      return pos;
    });
  }
  validate(opts) {
    return super.validate(opts).chain((_) => {
      if (this.pockets && (this.pockets.white.king > 0 || this.pockets.black.king > 0)) {
        return n.err(new PositionError(IllegalSetup.Kings));
      }
      if ((this.pockets ? this.pockets.count() : 0) + this.board.occupied.size() > 64) {
        return n.err(new PositionError(IllegalSetup.Variant));
      }
      return n.ok(void 0);
    });
  }
  clone() {
    return super.clone();
  }
  hasInsufficientMaterial(color) {
    if (!this.pockets)
      return super.hasInsufficientMaterial(color);
    return this.board.occupied.size() + this.pockets.count() <= 3 && this.board.pawn.isEmpty() && this.board.promoted.isEmpty() && this.board.rooksAndQueens().isEmpty() && this.pockets.white.pawn <= 0 && this.pockets.black.pawn <= 0 && this.pockets.white.rook <= 0 && this.pockets.black.rook <= 0 && this.pockets.white.queen <= 0 && this.pockets.black.queen <= 0;
  }
  dropDests(ctx) {
    var _a, _b;
    const mask = this.board.occupied.complement().intersect(((_a = this.pockets) === null || _a === void 0 ? void 0 : _a[this.turn].hasNonPawns()) ? SquareSet.full() : ((_b = this.pockets) === null || _b === void 0 ? void 0 : _b[this.turn].hasPawns()) ? SquareSet.backranks().complement() : SquareSet.empty());
    ctx = ctx || this.ctx();
    if (defined(ctx.king) && ctx.checkers.nonEmpty()) {
      const checker = ctx.checkers.singleSquare();
      if (!defined(checker))
        return SquareSet.empty();
      return mask.intersect(between(checker, ctx.king));
    } else
      return mask;
  }
};
var Atomic = class extends Chess {
  constructor() {
    super("atomic");
  }
  static default() {
    return super.default();
  }
  static fromSetup(setup, opts) {
    return super.fromSetup(setup, opts);
  }
  clone() {
    return super.clone();
  }
  validate(opts) {
    if (this.board.occupied.isEmpty())
      return n.err(new PositionError(IllegalSetup.Empty));
    if (this.board.king.size() > 2)
      return n.err(new PositionError(IllegalSetup.Kings));
    const otherKing = this.board.kingOf(opposite(this.turn));
    if (!defined(otherKing))
      return n.err(new PositionError(IllegalSetup.Kings));
    if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {
      return n.err(new PositionError(IllegalSetup.OppositeCheck));
    }
    if (SquareSet.backranks().intersects(this.board.pawn)) {
      return n.err(new PositionError(IllegalSetup.PawnsOnBackrank));
    }
    return (opts === null || opts === void 0 ? void 0 : opts.ignoreImpossibleCheck) ? n.ok(void 0) : this.validateCheckers();
  }
  validateCheckers() {
    return defined(this.epSquare) ? n.ok(void 0) : super.validateCheckers();
  }
  kingAttackers(square2, attacker, occupied) {
    const attackerKings = this.board.pieces(attacker, "king");
    if (attackerKings.isEmpty() || kingAttacks(square2).intersects(attackerKings)) {
      return SquareSet.empty();
    }
    return super.kingAttackers(square2, attacker, occupied);
  }
  playCaptureAt(square2, captured) {
    super.playCaptureAt(square2, captured);
    this.board.take(square2);
    for (const explode of kingAttacks(square2).intersect(this.board.occupied).diff(this.board.pawn)) {
      const piece2 = this.board.take(explode);
      if (piece2 && piece2.role === "rook")
        this.castles.discardRook(explode);
      if (piece2 && piece2.role === "king")
        this.castles.discardSide(piece2.color);
    }
  }
  hasInsufficientMaterial(color) {
    if (this.board.pieces(opposite(color), "king").isEmpty())
      return false;
    if (this.board[color].diff(this.board.king).isEmpty())
      return true;
    if (this.board[opposite(color)].diff(this.board.king).nonEmpty()) {
      if (this.board.occupied.equals(this.board.bishop.union(this.board.king))) {
        if (!this.board.bishop.intersect(this.board.white).intersects(SquareSet.darkSquares())) {
          return !this.board.bishop.intersect(this.board.black).intersects(SquareSet.lightSquares());
        }
        if (!this.board.bishop.intersect(this.board.white).intersects(SquareSet.lightSquares())) {
          return !this.board.bishop.intersect(this.board.black).intersects(SquareSet.darkSquares());
        }
      }
      return false;
    }
    if (this.board.queen.nonEmpty() || this.board.pawn.nonEmpty())
      return false;
    if (this.board.knight.union(this.board.bishop).union(this.board.rook).isSingleSquare())
      return true;
    if (this.board.occupied.equals(this.board.knight.union(this.board.king))) {
      return this.board.knight.size() <= 2;
    }
    return false;
  }
  dests(square2, ctx) {
    ctx = ctx || this.ctx();
    let dests2 = SquareSet.empty();
    for (const to of this.pseudoDests(square2, ctx)) {
      const after = this.clone();
      after.play({ from: square2, to });
      const ourKing = after.board.kingOf(this.turn);
      if (defined(ourKing) && (!defined(after.board.kingOf(after.turn)) || after.kingAttackers(ourKing, after.turn, after.board.occupied).isEmpty())) {
        dests2 = dests2.with(to);
      }
    }
    return dests2;
  }
  isVariantEnd() {
    return !!this.variantOutcome();
  }
  variantOutcome(_ctx) {
    for (const color of COLORS) {
      if (this.board.pieces(color, "king").isEmpty())
        return { winner: opposite(color) };
    }
    return;
  }
};
var Antichess = class extends Chess {
  constructor() {
    super("antichess");
  }
  static default() {
    const pos = super.default();
    pos.castles = Castles.empty();
    return pos;
  }
  static fromSetup(setup, opts) {
    return super.fromSetup(setup, opts).map((pos) => {
      pos.castles = Castles.empty();
      return pos;
    });
  }
  clone() {
    return super.clone();
  }
  validate(_opts) {
    if (this.board.occupied.isEmpty())
      return n.err(new PositionError(IllegalSetup.Empty));
    if (SquareSet.backranks().intersects(this.board.pawn))
      return n.err(new PositionError(IllegalSetup.PawnsOnBackrank));
    return n.ok(void 0);
  }
  kingAttackers(_square, _attacker, _occupied) {
    return SquareSet.empty();
  }
  ctx() {
    const ctx = super.ctx();
    const enemy = this.board[opposite(this.turn)];
    for (const from of this.board[this.turn]) {
      if (this.pseudoDests(from, ctx).intersects(enemy)) {
        ctx.mustCapture = true;
        break;
      }
    }
    return ctx;
  }
  dests(square2, ctx) {
    ctx = ctx || this.ctx();
    const dests2 = this.pseudoDests(square2, ctx);
    if (!ctx.mustCapture)
      return dests2;
    return dests2.intersect(this.board[opposite(this.turn)]);
  }
  hasInsufficientMaterial(color) {
    if (this.board.occupied.equals(this.board.bishop)) {
      const weSomeOnLight = this.board[color].intersects(SquareSet.lightSquares());
      const weSomeOnDark = this.board[color].intersects(SquareSet.darkSquares());
      const theyAllOnDark = this.board[opposite(color)].isDisjoint(SquareSet.lightSquares());
      const theyAllOnLight = this.board[opposite(color)].isDisjoint(SquareSet.darkSquares());
      return weSomeOnLight && theyAllOnDark || weSomeOnDark && theyAllOnLight;
    }
    return false;
  }
  isVariantEnd() {
    return this.board[this.turn].isEmpty();
  }
  variantOutcome(ctx) {
    ctx = ctx || this.ctx();
    if (ctx.variantEnd || this.isStalemate(ctx)) {
      return { winner: this.turn };
    }
    return;
  }
};
var KingOfTheHill = class extends Chess {
  constructor() {
    super("kingofthehill");
  }
  static default() {
    return super.default();
  }
  static fromSetup(setup, opts) {
    return super.fromSetup(setup, opts);
  }
  clone() {
    return super.clone();
  }
  hasInsufficientMaterial(_color) {
    return false;
  }
  isVariantEnd() {
    return this.board.king.intersects(SquareSet.center());
  }
  variantOutcome(_ctx) {
    for (const color of COLORS) {
      if (this.board.pieces(color, "king").intersects(SquareSet.center()))
        return { winner: color };
    }
    return;
  }
};
var ThreeCheck = class extends Chess {
  constructor() {
    super("3check");
  }
  static default() {
    const pos = super.default();
    pos.remainingChecks = RemainingChecks.default();
    return pos;
  }
  static fromSetup(setup, opts) {
    return super.fromSetup(setup, opts).map((pos) => {
      pos.remainingChecks = setup.remainingChecks ? setup.remainingChecks.clone() : RemainingChecks.default();
      return pos;
    });
  }
  clone() {
    return super.clone();
  }
  hasInsufficientMaterial(color) {
    return this.board.pieces(color, "king").equals(this.board[color]);
  }
  isVariantEnd() {
    return !!this.remainingChecks && (this.remainingChecks.white <= 0 || this.remainingChecks.black <= 0);
  }
  variantOutcome(_ctx) {
    if (this.remainingChecks) {
      for (const color of COLORS) {
        if (this.remainingChecks[color] <= 0)
          return { winner: color };
      }
    }
    return;
  }
};
var RacingKings = class extends Chess {
  constructor() {
    super("racingkings");
  }
  static default() {
    const pos = new this();
    pos.board = Board.racingKings();
    pos.pockets = void 0;
    pos.turn = "white";
    pos.castles = Castles.empty();
    pos.epSquare = void 0;
    pos.remainingChecks = void 0;
    pos.halfmoves = 0;
    pos.fullmoves = 1;
    return pos;
  }
  static fromSetup(setup, opts) {
    return super.fromSetup(setup, opts).map((pos) => {
      pos.castles = Castles.empty();
      return pos;
    });
  }
  validate(opts) {
    if (this.isCheck() || this.board.pawn.nonEmpty())
      return n.err(new PositionError(IllegalSetup.Variant));
    return super.validate(opts);
  }
  clone() {
    return super.clone();
  }
  dests(square2, ctx) {
    ctx = ctx || this.ctx();
    if (square2 === ctx.king)
      return super.dests(square2, ctx);
    let dests2 = SquareSet.empty();
    for (const to of super.dests(square2, ctx)) {
      const move = { from: square2, to };
      const after = this.clone();
      after.play(move);
      if (!after.isCheck())
        dests2 = dests2.with(to);
    }
    return dests2;
  }
  hasInsufficientMaterial(_color) {
    return false;
  }
  isVariantEnd() {
    const goal = SquareSet.fromRank(7);
    const inGoal = this.board.king.intersect(goal);
    if (inGoal.isEmpty())
      return false;
    if (this.turn === "white" || inGoal.intersects(this.board.black))
      return true;
    const blackKing = this.board.kingOf("black");
    if (defined(blackKing)) {
      const occ = this.board.occupied.without(blackKing);
      for (const target of kingAttacks(blackKing).intersect(goal).diff(this.board.black)) {
        if (this.kingAttackers(target, "white", occ).isEmpty())
          return false;
      }
    }
    return true;
  }
  variantOutcome(ctx) {
    if (ctx ? !ctx.variantEnd : !this.isVariantEnd())
      return;
    const goal = SquareSet.fromRank(7);
    const blackInGoal = this.board.pieces("black", "king").intersects(goal);
    const whiteInGoal = this.board.pieces("white", "king").intersects(goal);
    if (blackInGoal && !whiteInGoal)
      return { winner: "black" };
    if (whiteInGoal && !blackInGoal)
      return { winner: "white" };
    return { winner: void 0 };
  }
};
var Horde = class extends Chess {
  constructor() {
    super("horde");
  }
  static default() {
    const pos = new this();
    pos.board = Board.horde();
    pos.pockets = void 0;
    pos.turn = "white";
    pos.castles = Castles.default();
    pos.castles.discardSide("white");
    pos.epSquare = void 0;
    pos.remainingChecks = void 0;
    pos.halfmoves = 0;
    pos.fullmoves = 1;
    return pos;
  }
  static fromSetup(setup, opts) {
    return super.fromSetup(setup, opts);
  }
  validate(opts) {
    if (this.board.occupied.isEmpty())
      return n.err(new PositionError(IllegalSetup.Empty));
    if (!this.board.king.isSingleSquare())
      return n.err(new PositionError(IllegalSetup.Kings));
    if (!this.board.king.diff(this.board.promoted).isSingleSquare())
      return n.err(new PositionError(IllegalSetup.Kings));
    const otherKing = this.board.kingOf(opposite(this.turn));
    if (defined(otherKing) && this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty())
      return n.err(new PositionError(IllegalSetup.OppositeCheck));
    for (const color of COLORS) {
      if (this.board.pieces(color, "pawn").intersects(SquareSet.backrank(opposite(color)))) {
        return n.err(new PositionError(IllegalSetup.PawnsOnBackrank));
      }
    }
    return (opts === null || opts === void 0 ? void 0 : opts.ignoreImpossibleCheck) ? n.ok(void 0) : this.validateCheckers();
  }
  clone() {
    return super.clone();
  }
  hasInsufficientMaterial(_color) {
    return false;
  }
  isVariantEnd() {
    return this.board.white.isEmpty() || this.board.black.isEmpty();
  }
  variantOutcome(_ctx) {
    if (this.board.white.isEmpty())
      return { winner: "black" };
    if (this.board.black.isEmpty())
      return { winner: "white" };
    return;
  }
};
function defaultPosition(rules) {
  switch (rules) {
    case "chess":
      return Chess.default();
    case "antichess":
      return Antichess.default();
    case "atomic":
      return Atomic.default();
    case "horde":
      return Horde.default();
    case "racingkings":
      return RacingKings.default();
    case "kingofthehill":
      return KingOfTheHill.default();
    case "3check":
      return ThreeCheck.default();
    case "crazyhouse":
      return Crazyhouse.default();
  }
}
function setupPosition(rules, setup, opts) {
  switch (rules) {
    case "chess":
      return Chess.fromSetup(setup, opts);
    case "antichess":
      return Antichess.fromSetup(setup, opts);
    case "atomic":
      return Atomic.fromSetup(setup, opts);
    case "horde":
      return Horde.fromSetup(setup, opts);
    case "racingkings":
      return RacingKings.fromSetup(setup, opts);
    case "kingofthehill":
      return KingOfTheHill.fromSetup(setup, opts);
    case "3check":
      return ThreeCheck.fromSetup(setup, opts);
    case "crazyhouse":
      return Crazyhouse.fromSetup(setup, opts);
  }
}
export {
  Board,
  CASTLING_SIDES,
  COLORS,
  Castles,
  Chess,
  FILE_NAMES,
  IllegalSetup,
  Material,
  MaterialSide,
  Position,
  PositionError,
  RANK_NAMES,
  ROLES,
  RULES,
  RemainingChecks,
  SquareSet,
  attacks,
  between,
  bishopAttacks,
  charToRole,
  compat_exports as compat,
  debug_exports as debug,
  defaultSetup,
  defined,
  fen_exports as fen,
  hash_exports as hash,
  isDrop,
  isNormal,
  kingAttacks,
  kingCastlesTo,
  knightAttacks,
  makeSquare,
  makeUci,
  opposite,
  parseSquare,
  parseUci,
  pawnAttacks,
  queenAttacks,
  ray,
  roleToChar,
  rookAttacks,
  san_exports as san,
  squareFile,
  squareRank,
  transform_exports as transform,
  variant_exports as variant
};
//# sourceMappingURL=chessops.js.map
