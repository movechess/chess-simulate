{
  "version": 3,
  "sources": ["../../chessops/src/attacks.ts", "../../chessops/src/chess.ts", "../../chessops/src/debug.ts", "../../chessops/src/hash.ts", "../../chessops/src/san.ts", "../../chessops/src/transform.ts", "../../chessops/src/variant.ts"],
  "sourcesContent": ["/**\n * Compute attacks and rays.\n *\n * These are low-level functions that can be used to implement chess rules.\n *\n * Implementation notes: Sliding attacks are computed using\n * [hyperbola quintessence](https://www.chessprogramming.org/Hyperbola_Quintessence).\n * Magic bitboards would deliver faster lookups, but also require\n * initializing considerably larger attack tables. On the web, initialization\n * time is important, so the chosen method may strike a better balance.\n *\n * @packageDocumentation\n */\n\nimport { squareFile, squareRank } from './util.js';\nimport { Square, Piece, Color, BySquare } from './types.js';\nimport { SquareSet } from './squareSet.js';\n\nfunction computeRange(square: Square, deltas: number[]): SquareSet {\n  let range = SquareSet.empty();\n  for (const delta of deltas) {\n    const sq = square + delta;\n    if (0 <= sq && sq < 64 && Math.abs(squareFile(square) - squareFile(sq)) <= 2) {\n      range = range.with(sq);\n    }\n  }\n  return range;\n}\n\nfunction tabulate<T>(f: (square: Square) => T): BySquare<T> {\n  const table = [];\n  for (let square = 0; square < 64; square++) table[square] = f(square);\n  return table;\n}\n\nconst KING_ATTACKS = tabulate(sq => computeRange(sq, [-9, -8, -7, -1, 1, 7, 8, 9]));\nconst KNIGHT_ATTACKS = tabulate(sq => computeRange(sq, [-17, -15, -10, -6, 6, 10, 15, 17]));\nconst PAWN_ATTACKS = {\n  white: tabulate(sq => computeRange(sq, [7, 9])),\n  black: tabulate(sq => computeRange(sq, [-7, -9])),\n};\n\n/**\n * Gets squares attacked or defended by a king on `square`.\n */\nexport function kingAttacks(square: Square): SquareSet {\n  return KING_ATTACKS[square];\n}\n\n/**\n * Gets squares attacked or defended by a knight on `square`.\n */\nexport function knightAttacks(square: Square): SquareSet {\n  return KNIGHT_ATTACKS[square];\n}\n\n/**\n * Gets squares attacked or defended by a pawn of the given `color`\n * on `square`.\n */\nexport function pawnAttacks(color: Color, square: Square): SquareSet {\n  return PAWN_ATTACKS[color][square];\n}\n\nconst FILE_RANGE = tabulate(sq => SquareSet.fromFile(squareFile(sq)).without(sq));\nconst RANK_RANGE = tabulate(sq => SquareSet.fromRank(squareRank(sq)).without(sq));\n\nconst DIAG_RANGE = tabulate(sq => {\n  const diag = new SquareSet(0x0804_0201, 0x8040_2010);\n  const shift = 8 * (squareRank(sq) - squareFile(sq));\n  return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);\n});\n\nconst ANTI_DIAG_RANGE = tabulate(sq => {\n  const diag = new SquareSet(0x1020_4080, 0x0102_0408);\n  const shift = 8 * (squareRank(sq) + squareFile(sq) - 7);\n  return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);\n});\n\nfunction hyperbola(bit: SquareSet, range: SquareSet, occupied: SquareSet): SquareSet {\n  let forward = occupied.intersect(range);\n  let reverse = forward.bswap64(); // Assumes no more than 1 bit per rank\n  forward = forward.minus64(bit);\n  reverse = reverse.minus64(bit.bswap64());\n  return forward.xor(reverse.bswap64()).intersect(range);\n}\n\nfunction fileAttacks(square: Square, occupied: SquareSet): SquareSet {\n  return hyperbola(SquareSet.fromSquare(square), FILE_RANGE[square], occupied);\n}\n\nfunction rankAttacks(square: Square, occupied: SquareSet): SquareSet {\n  const range = RANK_RANGE[square];\n  let forward = occupied.intersect(range);\n  let reverse = forward.rbit64();\n  forward = forward.minus64(SquareSet.fromSquare(square));\n  reverse = reverse.minus64(SquareSet.fromSquare(63 - square));\n  return forward.xor(reverse.rbit64()).intersect(range);\n}\n\n/**\n * Gets squares attacked or defended by a bishop on `square`, given `occupied`\n * squares.\n */\nexport function bishopAttacks(square: Square, occupied: SquareSet): SquareSet {\n  const bit = SquareSet.fromSquare(square);\n  return hyperbola(bit, DIAG_RANGE[square], occupied).xor(hyperbola(bit, ANTI_DIAG_RANGE[square], occupied));\n}\n\n/**\n * Gets squares attacked or defended by a rook on `square`, given `occupied`\n * squares.\n */\nexport function rookAttacks(square: Square, occupied: SquareSet): SquareSet {\n  return fileAttacks(square, occupied).xor(rankAttacks(square, occupied));\n}\n\n/**\n * Gets squares attacked or defended by a queen on `square`, given `occupied`\n * squares.\n */\nexport function queenAttacks(square: Square, occupied: SquareSet): SquareSet {\n  return bishopAttacks(square, occupied).xor(rookAttacks(square, occupied));\n}\n\n/**\n * Gets squares attacked or defended by a `piece` on `square`, given\n * `occupied` squares.\n */\nexport function attacks(piece: Piece, square: Square, occupied: SquareSet): SquareSet {\n  switch (piece.role) {\n    case 'pawn':\n      return pawnAttacks(piece.color, square);\n    case 'knight':\n      return knightAttacks(square);\n    case 'bishop':\n      return bishopAttacks(square, occupied);\n    case 'rook':\n      return rookAttacks(square, occupied);\n    case 'queen':\n      return queenAttacks(square, occupied);\n    case 'king':\n      return kingAttacks(square);\n  }\n}\n\n/**\n * Gets all squares of the rank, file or diagonal with the two squares\n * `a` and `b`, or an empty set if they are not aligned.\n */\nexport function ray(a: Square, b: Square): SquareSet {\n  const other = SquareSet.fromSquare(b);\n  if (RANK_RANGE[a].intersects(other)) return RANK_RANGE[a].with(a);\n  if (ANTI_DIAG_RANGE[a].intersects(other)) return ANTI_DIAG_RANGE[a].with(a);\n  if (DIAG_RANGE[a].intersects(other)) return DIAG_RANGE[a].with(a);\n  if (FILE_RANGE[a].intersects(other)) return FILE_RANGE[a].with(a);\n  return SquareSet.empty();\n}\n\n/**\n * Gets all squares between `a` and `b` (bounds not included), or an empty set\n * if they are not on the same rank, file or diagonal.\n */\nexport function between(a: Square, b: Square): SquareSet {\n  return ray(a, b)\n    .intersect(SquareSet.full().shl64(a).xor(SquareSet.full().shl64(b)))\n    .withoutFirst();\n}\n", "import { Result } from '@badrap/result';\nimport {\n  Rules,\n  CastlingSide,\n  CASTLING_SIDES,\n  Color,\n  COLORS,\n  Square,\n  ByColor,\n  ByCastlingSide,\n  Move,\n  NormalMove,\n  isDrop,\n  Piece,\n  Outcome,\n} from './types.js';\nimport { SquareSet } from './squareSet.js';\nimport { Board } from './board.js';\nimport { Setup, Material, RemainingChecks } from './setup.js';\nimport {\n  attacks,\n  bishopAttacks,\n  rookAttacks,\n  queenAttacks,\n  knightAttacks,\n  kingAttacks,\n  pawnAttacks,\n  between,\n  ray,\n} from './attacks.js';\nimport { kingCastlesTo, opposite, defined, squareRank } from './util.js';\n\nexport enum IllegalSetup {\n  Empty = 'ERR_EMPTY',\n  OppositeCheck = 'ERR_OPPOSITE_CHECK',\n  ImpossibleCheck = 'ERR_IMPOSSIBLE_CHECK',\n  PawnsOnBackrank = 'ERR_PAWNS_ON_BACKRANK',\n  Kings = 'ERR_KINGS',\n  Variant = 'ERR_VARIANT',\n}\n\nexport class PositionError extends Error {}\n\nexport interface FromSetupOpts {\n  ignoreImpossibleCheck?: boolean;\n}\n\nfunction attacksTo(square: Square, attacker: Color, board: Board, occupied: SquareSet): SquareSet {\n  return board[attacker].intersect(\n    rookAttacks(square, occupied)\n      .intersect(board.rooksAndQueens())\n      .union(bishopAttacks(square, occupied).intersect(board.bishopsAndQueens()))\n      .union(knightAttacks(square).intersect(board.knight))\n      .union(kingAttacks(square).intersect(board.king))\n      .union(pawnAttacks(opposite(attacker), square).intersect(board.pawn))\n  );\n}\n\nfunction rookCastlesTo(color: Color, side: CastlingSide): Square {\n  return color === 'white' ? (side === 'a' ? 3 : 5) : side === 'a' ? 59 : 61;\n}\n\nexport class Castles {\n  unmovedRooks: SquareSet;\n  rook: ByColor<ByCastlingSide<Square | undefined>>;\n  path: ByColor<ByCastlingSide<SquareSet>>;\n\n  private constructor() {}\n\n  static default(): Castles {\n    const castles = new Castles();\n    castles.unmovedRooks = SquareSet.corners();\n    castles.rook = {\n      white: { a: 0, h: 7 },\n      black: { a: 56, h: 63 },\n    };\n    castles.path = {\n      white: { a: new SquareSet(0xe, 0), h: new SquareSet(0x60, 0) },\n      black: { a: new SquareSet(0, 0x0e000000), h: new SquareSet(0, 0x60000000) },\n    };\n    return castles;\n  }\n\n  static empty(): Castles {\n    const castles = new Castles();\n    castles.unmovedRooks = SquareSet.empty();\n    castles.rook = {\n      white: { a: undefined, h: undefined },\n      black: { a: undefined, h: undefined },\n    };\n    castles.path = {\n      white: { a: SquareSet.empty(), h: SquareSet.empty() },\n      black: { a: SquareSet.empty(), h: SquareSet.empty() },\n    };\n    return castles;\n  }\n\n  clone(): Castles {\n    const castles = new Castles();\n    castles.unmovedRooks = this.unmovedRooks;\n    castles.rook = {\n      white: { a: this.rook.white.a, h: this.rook.white.h },\n      black: { a: this.rook.black.a, h: this.rook.black.h },\n    };\n    castles.path = {\n      white: { a: this.path.white.a, h: this.path.white.h },\n      black: { a: this.path.black.a, h: this.path.black.h },\n    };\n    return castles;\n  }\n\n  private add(color: Color, side: CastlingSide, king: Square, rook: Square): void {\n    const kingTo = kingCastlesTo(color, side);\n    const rookTo = rookCastlesTo(color, side);\n    this.unmovedRooks = this.unmovedRooks.with(rook);\n    this.rook[color][side] = rook;\n    this.path[color][side] = between(rook, rookTo)\n      .with(rookTo)\n      .union(between(king, kingTo).with(kingTo))\n      .without(king)\n      .without(rook);\n  }\n\n  static fromSetup(setup: Setup): Castles {\n    const castles = Castles.empty();\n    const rooks = setup.unmovedRooks.intersect(setup.board.rook);\n    for (const color of COLORS) {\n      const backrank = SquareSet.backrank(color);\n      const king = setup.board.kingOf(color);\n      if (!defined(king) || !backrank.has(king)) continue;\n      const side = rooks.intersect(setup.board[color]).intersect(backrank);\n      const aSide = side.first();\n      if (defined(aSide) && aSide < king) castles.add(color, 'a', king, aSide);\n      const hSide = side.last();\n      if (defined(hSide) && king < hSide) castles.add(color, 'h', king, hSide);\n    }\n    return castles;\n  }\n\n  discardRook(square: Square): void {\n    if (this.unmovedRooks.has(square)) {\n      this.unmovedRooks = this.unmovedRooks.without(square);\n      for (const color of COLORS) {\n        for (const side of CASTLING_SIDES) {\n          if (this.rook[color][side] === square) this.rook[color][side] = undefined;\n        }\n      }\n    }\n  }\n\n  discardSide(color: Color): void {\n    this.unmovedRooks = this.unmovedRooks.diff(SquareSet.backrank(color));\n    this.rook[color].a = undefined;\n    this.rook[color].h = undefined;\n  }\n}\n\nexport interface Context {\n  king: Square | undefined;\n  blockers: SquareSet;\n  checkers: SquareSet;\n  variantEnd: boolean;\n  mustCapture: boolean;\n}\n\nexport abstract class Position {\n  board: Board;\n  pockets: Material | undefined;\n  turn: Color;\n  castles: Castles;\n  epSquare: Square | undefined;\n  remainingChecks: RemainingChecks | undefined;\n  halfmoves: number;\n  fullmoves: number;\n\n  protected constructor(readonly rules: Rules) {}\n\n  // When subclassing:\n  // - static default()\n  // - static fromSetup()\n  // - Proper signature for clone()\n\n  abstract dests(square: Square, ctx?: Context): SquareSet;\n  abstract isVariantEnd(): boolean;\n  abstract variantOutcome(ctx?: Context): Outcome | undefined;\n  abstract hasInsufficientMaterial(color: Color): boolean;\n\n  protected kingAttackers(square: Square, attacker: Color, occupied: SquareSet): SquareSet {\n    return attacksTo(square, attacker, this.board, occupied);\n  }\n\n  dropDests(_ctx?: Context): SquareSet {\n    return SquareSet.empty();\n  }\n\n  protected playCaptureAt(square: Square, captured: Piece): void {\n    this.halfmoves = 0;\n    if (captured.role === 'rook') this.castles.discardRook(square);\n    if (this.pockets) this.pockets[opposite(captured.color)][captured.role]++;\n  }\n\n  ctx(): Context {\n    const variantEnd = this.isVariantEnd();\n    const king = this.board.kingOf(this.turn);\n    if (!defined(king))\n      return { king, blockers: SquareSet.empty(), checkers: SquareSet.empty(), variantEnd, mustCapture: false };\n    const snipers = rookAttacks(king, SquareSet.empty())\n      .intersect(this.board.rooksAndQueens())\n      .union(bishopAttacks(king, SquareSet.empty()).intersect(this.board.bishopsAndQueens()))\n      .intersect(this.board[opposite(this.turn)]);\n    let blockers = SquareSet.empty();\n    for (const sniper of snipers) {\n      const b = between(king, sniper).intersect(this.board.occupied);\n      if (!b.moreThanOne()) blockers = blockers.union(b);\n    }\n    const checkers = this.kingAttackers(king, opposite(this.turn), this.board.occupied);\n    return {\n      king,\n      blockers,\n      checkers,\n      variantEnd,\n      mustCapture: false,\n    };\n  }\n\n  // The following should be identical in all subclasses\n\n  clone(): Position {\n    const pos = new (this as any).constructor();\n    pos.board = this.board.clone();\n    pos.pockets = this.pockets?.clone();\n    pos.turn = this.turn;\n    pos.castles = this.castles.clone();\n    pos.epSquare = this.epSquare;\n    pos.remainingChecks = this.remainingChecks?.clone();\n    pos.halfmoves = this.halfmoves;\n    pos.fullmoves = this.fullmoves;\n    return pos;\n  }\n\n  equalsIgnoreMoves(other: Position): boolean {\n    return (\n      this.rules === other.rules &&\n      (this.pockets ? this.board.equals(other.board) : this.board.equalsIgnorePromoted(other.board)) &&\n      ((other.pockets && this.pockets?.equals(other.pockets)) || (!this.pockets && !other.pockets)) &&\n      this.turn === other.turn &&\n      this.castles.unmovedRooks.equals(other.castles.unmovedRooks) &&\n      this.legalEpSquare() === other.legalEpSquare() &&\n      ((other.remainingChecks && this.remainingChecks?.equals(other.remainingChecks)) ||\n        (!this.remainingChecks && !other.remainingChecks))\n    );\n  }\n\n  toSetup(): Setup {\n    return {\n      board: this.board.clone(),\n      pockets: this.pockets?.clone(),\n      turn: this.turn,\n      unmovedRooks: this.castles.unmovedRooks,\n      epSquare: this.legalEpSquare(),\n      remainingChecks: this.remainingChecks?.clone(),\n      halfmoves: Math.min(this.halfmoves, 150),\n      fullmoves: Math.min(Math.max(this.fullmoves, 1), 9999),\n    };\n  }\n\n  isInsufficientMaterial(): boolean {\n    return COLORS.every(color => this.hasInsufficientMaterial(color));\n  }\n\n  hasDests(ctx?: Context): boolean {\n    ctx = ctx || this.ctx();\n    for (const square of this.board[this.turn]) {\n      if (this.dests(square, ctx).nonEmpty()) return true;\n    }\n    return this.dropDests(ctx).nonEmpty();\n  }\n\n  isLegal(move: Move, ctx?: Context): boolean {\n    if (isDrop(move)) {\n      if (!this.pockets || this.pockets[this.turn][move.role] <= 0) return false;\n      if (move.role === 'pawn' && SquareSet.backranks().has(move.to)) return false;\n      return this.dropDests(ctx).has(move.to);\n    } else {\n      if (move.promotion === 'pawn') return false;\n      if (move.promotion === 'king' && this.rules !== 'antichess') return false;\n      if (!!move.promotion !== (this.board.pawn.has(move.from) && SquareSet.backranks().has(move.to))) return false;\n      const dests = this.dests(move.from, ctx);\n      return dests.has(move.to) || dests.has(this.normalizeMove(move).to);\n    }\n  }\n\n  isCheck(): boolean {\n    const king = this.board.kingOf(this.turn);\n    return defined(king) && this.kingAttackers(king, opposite(this.turn), this.board.occupied).nonEmpty();\n  }\n\n  isEnd(ctx?: Context): boolean {\n    if (ctx ? ctx.variantEnd : this.isVariantEnd()) return true;\n    return this.isInsufficientMaterial() || !this.hasDests(ctx);\n  }\n\n  isCheckmate(ctx?: Context): boolean {\n    ctx = ctx || this.ctx();\n    return !ctx.variantEnd && ctx.checkers.nonEmpty() && !this.hasDests(ctx);\n  }\n\n  isStalemate(ctx?: Context): boolean {\n    ctx = ctx || this.ctx();\n    return !ctx.variantEnd && ctx.checkers.isEmpty() && !this.hasDests(ctx);\n  }\n\n  outcome(ctx?: Context): Outcome | undefined {\n    const variantOutcome = this.variantOutcome(ctx);\n    if (variantOutcome) return variantOutcome;\n    ctx = ctx || this.ctx();\n    if (this.isCheckmate(ctx)) return { winner: opposite(this.turn) };\n    else if (this.isInsufficientMaterial() || this.isStalemate(ctx)) return { winner: undefined };\n    else return;\n  }\n\n  allDests(ctx?: Context): Map<Square, SquareSet> {\n    ctx = ctx || this.ctx();\n    const d = new Map();\n    if (ctx.variantEnd) return d;\n    for (const square of this.board[this.turn]) {\n      d.set(square, this.dests(square, ctx));\n    }\n    return d;\n  }\n\n  castlingSide(move: Move): CastlingSide | undefined {\n    if (isDrop(move)) return;\n    const delta = move.to - move.from;\n    if (Math.abs(delta) !== 2 && !this.board[this.turn].has(move.to)) return;\n    if (!this.board.king.has(move.from)) return;\n    return delta > 0 ? 'h' : 'a';\n  }\n\n  normalizeMove(move: Move): Move {\n    const castlingSide = this.castlingSide(move);\n    if (!castlingSide) return move;\n    const rookFrom = this.castles.rook[this.turn][castlingSide];\n    return {\n      from: (move as NormalMove).from,\n      to: defined(rookFrom) ? rookFrom : move.to,\n    };\n  }\n\n  play(move: Move): void {\n    const turn = this.turn;\n    const epSquare = this.epSquare;\n    const castlingSide = this.castlingSide(move);\n\n    this.epSquare = undefined;\n    this.halfmoves += 1;\n    if (turn === 'black') this.fullmoves += 1;\n    this.turn = opposite(turn);\n\n    if (isDrop(move)) {\n      this.board.set(move.to, { role: move.role, color: turn });\n      if (this.pockets) this.pockets[turn][move.role]--;\n      if (move.role === 'pawn') this.halfmoves = 0;\n    } else {\n      const piece = this.board.take(move.from);\n      if (!piece) return;\n\n      let epCapture: Piece | undefined;\n      if (piece.role === 'pawn') {\n        this.halfmoves = 0;\n        if (move.to === epSquare) {\n          epCapture = this.board.take(move.to + (turn === 'white' ? -8 : 8));\n        }\n        const delta = move.from - move.to;\n        if (Math.abs(delta) === 16 && 8 <= move.from && move.from <= 55) {\n          this.epSquare = (move.from + move.to) >> 1;\n        }\n        if (move.promotion) {\n          piece.role = move.promotion;\n          piece.promoted = true;\n        }\n      } else if (piece.role === 'rook') {\n        this.castles.discardRook(move.from);\n      } else if (piece.role === 'king') {\n        if (castlingSide) {\n          const rookFrom = this.castles.rook[turn][castlingSide];\n          if (defined(rookFrom)) {\n            const rook = this.board.take(rookFrom);\n            this.board.set(kingCastlesTo(turn, castlingSide), piece);\n            if (rook) this.board.set(rookCastlesTo(turn, castlingSide), rook);\n          }\n        }\n        this.castles.discardSide(turn);\n      }\n\n      if (!castlingSide) {\n        const capture = this.board.set(move.to, piece) || epCapture;\n        if (capture) this.playCaptureAt(move.to, capture);\n      }\n    }\n\n    if (this.remainingChecks) {\n      if (this.isCheck()) this.remainingChecks[turn] = Math.max(this.remainingChecks[turn] - 1, 0);\n    }\n  }\n\n  private legalEpSquare(ctx?: Context): Square | undefined {\n    if (!defined(this.epSquare)) return;\n    ctx = ctx || this.ctx();\n    const ourPawns = this.board.pieces(this.turn, 'pawn');\n    const candidates = ourPawns.intersect(pawnAttacks(opposite(this.turn), this.epSquare));\n    for (const candidate of candidates) {\n      if (this.dests(candidate, ctx).has(this.epSquare)) return this.epSquare;\n    }\n    return;\n  }\n}\n\nexport class Chess extends Position {\n  protected constructor(rules?: Rules) {\n    super(rules || 'chess');\n  }\n\n  static default(): Chess {\n    const pos = new this();\n    pos.board = Board.default();\n    pos.pockets = undefined;\n    pos.turn = 'white';\n    pos.castles = Castles.default();\n    pos.epSquare = undefined;\n    pos.remainingChecks = undefined;\n    pos.halfmoves = 0;\n    pos.fullmoves = 1;\n    return pos;\n  }\n\n  static fromSetup(setup: Setup, opts?: FromSetupOpts): Result<Chess, PositionError> {\n    const pos = new this();\n    pos.board = setup.board.clone();\n    pos.pockets = undefined;\n    pos.turn = setup.turn;\n    pos.castles = Castles.fromSetup(setup);\n    pos.epSquare = pos.validEpSquare(setup.epSquare);\n    pos.remainingChecks = undefined;\n    pos.halfmoves = setup.halfmoves;\n    pos.fullmoves = setup.fullmoves;\n    return pos.validate(opts).map(_ => pos);\n  }\n\n  clone(): Chess {\n    return super.clone() as Chess;\n  }\n\n  protected validate(opts?: FromSetupOpts): Result<undefined, PositionError> {\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (this.board.king.size() !== 2) return Result.err(new PositionError(IllegalSetup.Kings));\n\n    if (!defined(this.board.kingOf(this.turn))) return Result.err(new PositionError(IllegalSetup.Kings));\n\n    const otherKing = this.board.kingOf(opposite(this.turn));\n    if (!defined(otherKing)) return Result.err(new PositionError(IllegalSetup.Kings));\n    if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty())\n      return Result.err(new PositionError(IllegalSetup.OppositeCheck));\n\n    if (SquareSet.backranks().intersects(this.board.pawn))\n      return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n\n    return opts?.ignoreImpossibleCheck ? Result.ok(undefined) : this.validateCheckers();\n  }\n\n  protected validateCheckers(): Result<undefined, PositionError> {\n    const ourKing = this.board.kingOf(this.turn);\n    if (defined(ourKing)) {\n      const checkers = this.kingAttackers(ourKing, opposite(this.turn), this.board.occupied);\n      if (checkers.nonEmpty()) {\n        if (defined(this.epSquare)) {\n          // The pushed pawn must be the only checker, or it has uncovered\n          // check by a single sliding piece.\n          const pushedTo = this.epSquare ^ 8;\n          const pushedFrom = this.epSquare ^ 24;\n          if (\n            checkers.moreThanOne() ||\n            (checkers.first()! != pushedTo &&\n              this.kingAttackers(\n                ourKing,\n                opposite(this.turn),\n                this.board.occupied.without(pushedTo).with(pushedFrom)\n              ).nonEmpty())\n          )\n            return Result.err(new PositionError(IllegalSetup.ImpossibleCheck));\n        } else {\n          // Multiple sliding checkers aligned with king.\n          if (checkers.size() > 2 || (checkers.size() === 2 && ray(checkers.first()!, checkers.last()!).has(ourKing)))\n            return Result.err(new PositionError(IllegalSetup.ImpossibleCheck));\n        }\n      }\n    }\n    return Result.ok(undefined);\n  }\n\n  private validEpSquare(square: Square | undefined): Square | undefined {\n    if (!defined(square)) return;\n    const epRank = this.turn === 'white' ? 5 : 2;\n    const forward = this.turn === 'white' ? 8 : -8;\n    if (squareRank(square) !== epRank) return;\n    if (this.board.occupied.has(square + forward)) return;\n    const pawn = square - forward;\n    if (!this.board.pawn.has(pawn) || !this.board[opposite(this.turn)].has(pawn)) return;\n    return square;\n  }\n\n  private castlingDest(side: CastlingSide, ctx: Context): SquareSet {\n    if (!defined(ctx.king) || ctx.checkers.nonEmpty()) return SquareSet.empty();\n    const rook = this.castles.rook[this.turn][side];\n    if (!defined(rook)) return SquareSet.empty();\n    if (this.castles.path[this.turn][side].intersects(this.board.occupied)) return SquareSet.empty();\n\n    const kingTo = kingCastlesTo(this.turn, side);\n    const kingPath = between(ctx.king, kingTo);\n    const occ = this.board.occupied.without(ctx.king);\n    for (const sq of kingPath) {\n      if (this.kingAttackers(sq, opposite(this.turn), occ).nonEmpty()) return SquareSet.empty();\n    }\n\n    const rookTo = rookCastlesTo(this.turn, side);\n    const after = this.board.occupied.toggle(ctx.king).toggle(rook).toggle(rookTo);\n    if (this.kingAttackers(kingTo, opposite(this.turn), after).nonEmpty()) return SquareSet.empty();\n\n    return SquareSet.fromSquare(rook);\n  }\n\n  private canCaptureEp(pawn: Square, ctx: Context): boolean {\n    if (!defined(this.epSquare)) return false;\n    if (!pawnAttacks(this.turn, pawn).has(this.epSquare)) return false;\n    if (!defined(ctx.king)) return true;\n    const captured = this.epSquare + (this.turn === 'white' ? -8 : 8);\n    const occupied = this.board.occupied.toggle(pawn).toggle(this.epSquare).toggle(captured);\n    return !this.kingAttackers(ctx.king, opposite(this.turn), occupied).intersects(occupied);\n  }\n\n  protected pseudoDests(square: Square, ctx: Context): SquareSet {\n    if (ctx.variantEnd) return SquareSet.empty();\n    const piece = this.board.get(square);\n    if (!piece || piece.color !== this.turn) return SquareSet.empty();\n\n    let pseudo = attacks(piece, square, this.board.occupied);\n    if (piece.role === 'pawn') {\n      let captureTargets = this.board[opposite(this.turn)];\n      if (defined(this.epSquare)) captureTargets = captureTargets.with(this.epSquare);\n      pseudo = pseudo.intersect(captureTargets);\n      const delta = this.turn === 'white' ? 8 : -8;\n      const step = square + delta;\n      if (0 <= step && step < 64 && !this.board.occupied.has(step)) {\n        pseudo = pseudo.with(step);\n        const canDoubleStep = this.turn === 'white' ? square < 16 : square >= 64 - 16;\n        const doubleStep = step + delta;\n        if (canDoubleStep && !this.board.occupied.has(doubleStep)) {\n          pseudo = pseudo.with(doubleStep);\n        }\n      }\n      return pseudo;\n    } else {\n      pseudo = pseudo.diff(this.board[this.turn]);\n    }\n    if (square === ctx.king) return pseudo.union(this.castlingDest('a', ctx)).union(this.castlingDest('h', ctx));\n    else return pseudo;\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n    if (ctx.variantEnd) return SquareSet.empty();\n    const piece = this.board.get(square);\n    if (!piece || piece.color !== this.turn) return SquareSet.empty();\n\n    let pseudo, legal;\n    if (piece.role === 'pawn') {\n      pseudo = pawnAttacks(this.turn, square).intersect(this.board[opposite(this.turn)]);\n      const delta = this.turn === 'white' ? 8 : -8;\n      const step = square + delta;\n      if (0 <= step && step < 64 && !this.board.occupied.has(step)) {\n        pseudo = pseudo.with(step);\n        const canDoubleStep = this.turn === 'white' ? square < 16 : square >= 64 - 16;\n        const doubleStep = step + delta;\n        if (canDoubleStep && !this.board.occupied.has(doubleStep)) {\n          pseudo = pseudo.with(doubleStep);\n        }\n      }\n      if (defined(this.epSquare) && this.canCaptureEp(square, ctx)) {\n        const pawn = this.epSquare - delta;\n        if (ctx.checkers.isEmpty() || ctx.checkers.singleSquare() === pawn) {\n          legal = SquareSet.fromSquare(this.epSquare);\n        }\n      }\n    } else if (piece.role === 'bishop') pseudo = bishopAttacks(square, this.board.occupied);\n    else if (piece.role === 'knight') pseudo = knightAttacks(square);\n    else if (piece.role === 'rook') pseudo = rookAttacks(square, this.board.occupied);\n    else if (piece.role === 'queen') pseudo = queenAttacks(square, this.board.occupied);\n    else pseudo = kingAttacks(square);\n\n    pseudo = pseudo.diff(this.board[this.turn]);\n\n    if (defined(ctx.king)) {\n      if (piece.role === 'king') {\n        const occ = this.board.occupied.without(square);\n        for (const to of pseudo) {\n          if (this.kingAttackers(to, opposite(this.turn), occ).nonEmpty()) pseudo = pseudo.without(to);\n        }\n        return pseudo.union(this.castlingDest('a', ctx)).union(this.castlingDest('h', ctx));\n      }\n\n      if (ctx.checkers.nonEmpty()) {\n        const checker = ctx.checkers.singleSquare();\n        if (!defined(checker)) return SquareSet.empty();\n        pseudo = pseudo.intersect(between(checker, ctx.king).with(checker));\n      }\n\n      if (ctx.blockers.has(square)) pseudo = pseudo.intersect(ray(square, ctx.king));\n    }\n\n    if (legal) pseudo = pseudo.union(legal);\n    return pseudo;\n  }\n\n  isVariantEnd(): boolean {\n    return false;\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    return;\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    if (this.board[color].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty()) return false;\n    if (this.board[color].intersects(this.board.knight)) {\n      return (\n        this.board[color].size() <= 2 &&\n        this.board[opposite(color)].diff(this.board.king).diff(this.board.queen).isEmpty()\n      );\n    }\n    if (this.board[color].intersects(this.board.bishop)) {\n      const sameColor =\n        !this.board.bishop.intersects(SquareSet.darkSquares()) ||\n        !this.board.bishop.intersects(SquareSet.lightSquares());\n      return sameColor && this.board.pawn.isEmpty() && this.board.knight.isEmpty();\n    }\n    return true;\n  }\n}\n", "import { Square, Piece, Role, ROLES } from './types.js';\nimport { opposite, squareRank, makeSquare, makeUci } from './util.js';\nimport { makePiece } from './fen.js';\nimport { SquareSet } from './squareSet.js';\nimport { Board } from './board.js';\nimport { Position } from './chess.js';\n\nexport function squareSet(squares: SquareSet): string {\n  const r = [];\n  for (let y = 7; y >= 0; y--) {\n    for (let x = 0; x < 8; x++) {\n      const square = x + y * 8;\n      r.push(squares.has(square) ? '1' : '.');\n      r.push(x < 7 ? ' ' : '\\n');\n    }\n  }\n  return r.join('');\n}\n\nexport function piece(piece: Piece): string {\n  return makePiece(piece);\n}\n\nexport function board(board: Board): string {\n  const r = [];\n  for (let y = 7; y >= 0; y--) {\n    for (let x = 0; x < 8; x++) {\n      const square = x + y * 8;\n      const p = board.get(square);\n      const col = p ? piece(p) : '.';\n      r.push(col);\n      r.push(x < 7 ? (col.length < 2 ? ' ' : '') : '\\n');\n    }\n  }\n  return r.join('');\n}\n\nexport function square(sq: Square): string {\n  return makeSquare(sq);\n}\n\nexport function dests(dests: Map<Square, SquareSet>): string {\n  const lines = [];\n  for (const [from, to] of dests) {\n    lines.push(`${makeSquare(from)}: ${Array.from(to, square).join(' ')}`);\n  }\n  return lines.join('\\n');\n}\n\nexport function perft(pos: Position, depth: number, log = false): number {\n  if (depth < 1) return 1;\n\n  const promotionRoles: Role[] = ['queen', 'knight', 'rook', 'bishop'];\n  if (pos.rules === 'antichess') promotionRoles.push('king');\n\n  const ctx = pos.ctx();\n  const dropDests = pos.dropDests(ctx);\n\n  if (!log && depth === 1 && dropDests.isEmpty()) {\n    // Optimization for leaf nodes.\n    let nodes = 0;\n    for (const [from, to] of pos.allDests(ctx)) {\n      nodes += to.size();\n      if (pos.board.pawn.has(from)) {\n        const backrank = SquareSet.backrank(opposite(pos.turn));\n        nodes += to.intersect(backrank).size() * (promotionRoles.length - 1);\n      }\n    }\n    return nodes;\n  } else {\n    let nodes = 0;\n    for (const [from, dests] of pos.allDests(ctx)) {\n      const promotions: Array<Role | undefined> =\n        squareRank(from) === (pos.turn === 'white' ? 6 : 1) && pos.board.pawn.has(from) ? promotionRoles : [undefined];\n      for (const to of dests) {\n        for (const promotion of promotions) {\n          const child = pos.clone();\n          const move = { from, to, promotion };\n          child.play(move);\n          const children = perft(child, depth - 1, false);\n          if (log) console.log(makeUci(move), children);\n          nodes += children;\n        }\n      }\n    }\n    if (pos.pockets) {\n      for (const role of ROLES) {\n        if (pos.pockets[pos.turn][role] > 0) {\n          for (const to of role === 'pawn' ? dropDests.diff(SquareSet.backranks()) : dropDests) {\n            const child = pos.clone();\n            const move = { role, to };\n            child.play(move);\n            const children = perft(child, depth - 1, false);\n            if (log) console.log(makeUci(move), children);\n            nodes += children;\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n}\n", "import { COLORS, ROLES } from './types.js';\nimport { defined } from './util.js';\nimport { Board } from './board.js';\nimport { Setup, MaterialSide, Material, RemainingChecks } from './setup.js';\n\nfunction rol32(n: number, left: number): number {\n  return (n << left) | (n >>> (32 - left));\n}\n\nexport function fxhash32(word: number, state = 0): number {\n  return Math.imul(rol32(state, 5) ^ word, 0x9e3779b9);\n}\n\nexport function hashBoard(board: Board, state = 0): number {\n  state = fxhash32(board.white.lo, fxhash32(board.white.hi, state));\n  for (const role of ROLES) state = fxhash32(board[role].lo, fxhash32(board[role].hi, state));\n  return state;\n}\n\nexport function hashMaterialSide(side: MaterialSide, state = 0): number {\n  for (const role of ROLES) state = fxhash32(side[role], state);\n  return state;\n}\n\nexport function hashMaterial(material: Material, state = 0): number {\n  for (const color of COLORS) state = hashMaterialSide(material[color], state);\n  return state;\n}\n\nexport function hashRemainingChecks(checks: RemainingChecks, state = 0): number {\n  return fxhash32(checks.white, fxhash32(checks.black, state));\n}\n\nexport function hashSetup(setup: Setup, state = 0): number {\n  state = hashBoard(setup.board, state);\n  if (setup.pockets) state = hashMaterial(setup.pockets, state);\n  if (setup.turn === 'white') state = fxhash32(1, state);\n  state = fxhash32(setup.unmovedRooks.lo, fxhash32(setup.unmovedRooks.hi, state));\n  if (defined(setup.epSquare)) state = fxhash32(setup.epSquare, state);\n  if (setup.remainingChecks) state = hashRemainingChecks(setup.remainingChecks, state);\n  return state;\n}\n", "import { FILE_NAMES, RANK_NAMES, isDrop, Move, CastlingSide } from './types.js';\nimport { charToRole, defined, roleToChar, parseSquare, makeSquare, squareFile, squareRank, opposite } from './util.js';\nimport { SquareSet } from './squareSet.js';\nimport { Position } from './chess.js';\nimport { attacks, kingAttacks, queenAttacks, rookAttacks, bishopAttacks, knightAttacks } from './attacks.js';\n\nfunction makeSanWithoutSuffix(pos: Position, move: Move): string {\n  let san = '';\n  if (isDrop(move)) {\n    if (move.role !== 'pawn') san = roleToChar(move.role).toUpperCase();\n    san += '@' + makeSquare(move.to);\n  } else {\n    const role = pos.board.getRole(move.from);\n    if (!role) return '--';\n    if (role === 'king' && (pos.board[pos.turn].has(move.to) || Math.abs(move.to - move.from) === 2)) {\n      san = move.to > move.from ? 'O-O' : 'O-O-O';\n    } else {\n      const capture =\n        pos.board.occupied.has(move.to) || (role === 'pawn' && squareFile(move.from) !== squareFile(move.to));\n      if (role !== 'pawn') {\n        san = roleToChar(role).toUpperCase();\n\n        // Disambiguation\n        let others;\n        if (role === 'king') others = kingAttacks(move.to).intersect(pos.board.king);\n        else if (role === 'queen') others = queenAttacks(move.to, pos.board.occupied).intersect(pos.board.queen);\n        else if (role === 'rook') others = rookAttacks(move.to, pos.board.occupied).intersect(pos.board.rook);\n        else if (role === 'bishop') others = bishopAttacks(move.to, pos.board.occupied).intersect(pos.board.bishop);\n        else others = knightAttacks(move.to).intersect(pos.board.knight);\n        others = others.intersect(pos.board[pos.turn]).without(move.from);\n        if (others.nonEmpty()) {\n          const ctx = pos.ctx();\n          for (const from of others) {\n            if (!pos.dests(from, ctx).has(move.to)) others = others.without(from);\n          }\n          if (others.nonEmpty()) {\n            let row = false;\n            let column = others.intersects(SquareSet.fromRank(squareRank(move.from)));\n            if (others.intersects(SquareSet.fromFile(squareFile(move.from)))) row = true;\n            else column = true;\n            if (column) san += FILE_NAMES[squareFile(move.from)];\n            if (row) san += RANK_NAMES[squareRank(move.from)];\n          }\n        }\n      } else if (capture) san = FILE_NAMES[squareFile(move.from)];\n\n      if (capture) san += 'x';\n      san += makeSquare(move.to);\n      if (move.promotion) san += '=' + roleToChar(move.promotion).toUpperCase();\n    }\n  }\n  return san;\n}\n\nexport function makeSanAndPlay(pos: Position, move: Move): string {\n  const san = makeSanWithoutSuffix(pos, move);\n  pos.play(move);\n  if (pos.outcome()?.winner) return san + '#';\n  if (pos.isCheck()) return san + '+';\n  return san;\n}\n\nexport function makeSanVariation(pos: Position, variation: Move[]): string {\n  pos = pos.clone();\n  const line = [];\n  for (let i = 0; i < variation.length; i++) {\n    if (i !== 0) line.push(' ');\n    if (pos.turn === 'white') line.push(pos.fullmoves, '. ');\n    else if (i === 0) line.push(pos.fullmoves, '... ');\n    const san = makeSanWithoutSuffix(pos, variation[i]);\n    pos.play(variation[i]);\n    line.push(san);\n    if (san === '--') return line.join('');\n    if (i === variation.length - 1 && pos.outcome()?.winner) line.push('#');\n    else if (pos.isCheck()) line.push('+');\n  }\n  return line.join('');\n}\n\nexport function makeSan(pos: Position, move: Move): string {\n  return makeSanAndPlay(pos.clone(), move);\n}\n\nexport function parseSan(pos: Position, san: string): Move | undefined {\n  const ctx = pos.ctx();\n\n  // Castling\n  let castlingSide: CastlingSide | undefined;\n  if (san === 'O-O' || san === 'O-O+' || san === 'O-O#') castlingSide = 'h';\n  else if (san === 'O-O-O' || san === 'O-O-O+' || san === 'O-O-O#') castlingSide = 'a';\n  if (castlingSide) {\n    const rook = pos.castles.rook[pos.turn][castlingSide];\n    if (!defined(ctx.king) || !defined(rook) || !pos.dests(ctx.king, ctx).has(rook)) return;\n    return {\n      from: ctx.king,\n      to: rook,\n    };\n  }\n\n  // Normal move\n  const match = san.match(/^([NBRQK])?([a-h])?([1-8])?[-x]?([a-h][1-8])(?:=?([nbrqkNBRQK]))?[+#]?$/);\n  if (!match) {\n    // Drop\n    const match = san.match(/^([pnbrqkPNBRQK])?@([a-h][1-8])[+#]?$/);\n    if (!match) return;\n    const move = {\n      role: charToRole(match[1]) || 'pawn',\n      to: parseSquare(match[2])!,\n    };\n    return pos.isLegal(move, ctx) ? move : undefined;\n  }\n  const role = charToRole(match[1]) || 'pawn';\n  const to = parseSquare(match[4])!;\n\n  const promotion = charToRole(match[5]);\n  if (!!promotion !== (role === 'pawn' && SquareSet.backranks().has(to))) return;\n  if (promotion === 'king' && pos.rules !== 'antichess') return;\n\n  let candidates = pos.board.pieces(pos.turn, role);\n  if (match[2]) candidates = candidates.intersect(SquareSet.fromFile(match[2].charCodeAt(0) - 'a'.charCodeAt(0)));\n  if (match[3]) candidates = candidates.intersect(SquareSet.fromRank(match[3].charCodeAt(0) - '1'.charCodeAt(0)));\n\n  // Optimization: Reduce set of candidates\n  const pawnAdvance = role === 'pawn' ? SquareSet.fromFile(squareFile(to)) : SquareSet.empty();\n  candidates = candidates.intersect(\n    pawnAdvance.union(attacks({ color: opposite(pos.turn), role }, to, pos.board.occupied))\n  );\n\n  // Check uniqueness and legality\n  let from;\n  for (const candidate of candidates) {\n    if (pos.dests(candidate, ctx).has(to)) {\n      if (defined(from)) return; // Ambiguous\n      from = candidate;\n    }\n  }\n  if (!defined(from)) return; // Illegal\n\n  return {\n    from,\n    to,\n    promotion,\n  };\n}\n", "import { ROLES, COLORS } from './types.js';\nimport { defined } from './util.js';\nimport { SquareSet } from './squareSet.js';\nimport { Board } from './board.js';\nimport { Setup } from './setup.js';\n\nexport function flipVertical(s: SquareSet): SquareSet {\n  return s.bswap64();\n}\n\nexport function flipHorizontal(s: SquareSet): SquareSet {\n  const k1 = new SquareSet(0x55555555, 0x55555555);\n  const k2 = new SquareSet(0x33333333, 0x33333333);\n  const k4 = new SquareSet(0x0f0f0f0f, 0x0f0f0f0f);\n  s = s.shr64(1).intersect(k1).union(s.intersect(k1).shl64(1));\n  s = s.shr64(2).intersect(k2).union(s.intersect(k2).shl64(2));\n  s = s.shr64(4).intersect(k4).union(s.intersect(k4).shl64(4));\n  return s;\n}\n\nexport function flipDiagonal(s: SquareSet): SquareSet {\n  let t = s.xor(s.shl64(28)).intersect(new SquareSet(0, 0x0f0f0f0f));\n  s = s.xor(t.xor(t.shr64(28)));\n  t = s.xor(s.shl64(14)).intersect(new SquareSet(0x33330000, 0x33330000));\n  s = s.xor(t.xor(t.shr64(14)));\n  t = s.xor(s.shl64(7)).intersect(new SquareSet(0x55005500, 0x55005500));\n  s = s.xor(t.xor(t.shr64(7)));\n  return s;\n}\n\nexport function rotate180(s: SquareSet): SquareSet {\n  return s.rbit64();\n}\n\nexport function transformBoard(board: Board, f: (s: SquareSet) => SquareSet): Board {\n  const b = Board.empty();\n  b.occupied = f(board.occupied);\n  b.promoted = f(board.promoted);\n  for (const color of COLORS) b[color] = f(board[color]);\n  for (const role of ROLES) b[role] = f(board[role]);\n  return b;\n}\n\nexport function transformSetup(setup: Setup, f: (s: SquareSet) => SquareSet): Setup {\n  return {\n    board: transformBoard(setup.board, f),\n    pockets: setup.pockets?.clone(),\n    turn: setup.turn,\n    unmovedRooks: f(setup.unmovedRooks),\n    epSquare: defined(setup.epSquare) ? f(SquareSet.fromSquare(setup.epSquare)).first() : undefined,\n    remainingChecks: setup.remainingChecks?.clone(),\n    halfmoves: setup.halfmoves,\n    fullmoves: setup.fullmoves,\n  };\n}\n", "import { Result } from '@badrap/result';\nimport { Square, Outcome, Color, COLORS, Piece, Rules } from './types.js';\nimport { defined, opposite } from './util.js';\nimport { between, kingAttacks } from './attacks.js';\nimport { SquareSet } from './squareSet.js';\nimport { Board } from './board.js';\nimport { Setup, RemainingChecks, Material } from './setup.js';\nimport { PositionError, Position, IllegalSetup, Context, Castles, Chess, FromSetupOpts } from './chess.js';\n\nexport { Position, PositionError, IllegalSetup, Context, Chess, Castles };\n\nexport class Crazyhouse extends Chess {\n  protected constructor() {\n    super('crazyhouse');\n  }\n\n  static default(): Crazyhouse {\n    const pos = super.default();\n    pos.pockets = Material.empty();\n    return pos as Crazyhouse;\n  }\n\n  static fromSetup(setup: Setup, opts?: FromSetupOpts): Result<Crazyhouse, PositionError> {\n    return super.fromSetup(setup, opts).map(pos => {\n      pos.pockets = setup.pockets ? setup.pockets.clone() : Material.empty();\n      return pos as Crazyhouse;\n    });\n  }\n\n  protected validate(opts?: FromSetupOpts): Result<undefined, PositionError> {\n    return super.validate(opts).chain(_ => {\n      if (this.pockets && (this.pockets.white.king > 0 || this.pockets.black.king > 0)) {\n        return Result.err(new PositionError(IllegalSetup.Kings));\n      }\n      if ((this.pockets ? this.pockets.count() : 0) + this.board.occupied.size() > 64) {\n        return Result.err(new PositionError(IllegalSetup.Variant));\n      }\n      return Result.ok(undefined);\n    });\n  }\n\n  clone(): Crazyhouse {\n    return super.clone() as Crazyhouse;\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    // No material can leave the game, but we can easily check this for\n    // custom positions.\n    if (!this.pockets) return super.hasInsufficientMaterial(color);\n    return (\n      this.board.occupied.size() + this.pockets.count() <= 3 &&\n      this.board.pawn.isEmpty() &&\n      this.board.promoted.isEmpty() &&\n      this.board.rooksAndQueens().isEmpty() &&\n      this.pockets.white.pawn <= 0 &&\n      this.pockets.black.pawn <= 0 &&\n      this.pockets.white.rook <= 0 &&\n      this.pockets.black.rook <= 0 &&\n      this.pockets.white.queen <= 0 &&\n      this.pockets.black.queen <= 0\n    );\n  }\n\n  dropDests(ctx?: Context): SquareSet {\n    const mask = this.board.occupied\n      .complement()\n      .intersect(\n        this.pockets?.[this.turn].hasNonPawns()\n          ? SquareSet.full()\n          : this.pockets?.[this.turn].hasPawns()\n          ? SquareSet.backranks().complement()\n          : SquareSet.empty()\n      );\n\n    ctx = ctx || this.ctx();\n    if (defined(ctx.king) && ctx.checkers.nonEmpty()) {\n      const checker = ctx.checkers.singleSquare();\n      if (!defined(checker)) return SquareSet.empty();\n      return mask.intersect(between(checker, ctx.king));\n    } else return mask;\n  }\n}\n\nexport class Atomic extends Chess {\n  protected constructor() {\n    super('atomic');\n  }\n\n  static default(): Atomic {\n    return super.default() as Atomic;\n  }\n\n  static fromSetup(setup: Setup, opts?: FromSetupOpts): Result<Atomic, PositionError> {\n    return super.fromSetup(setup, opts) as Result<Atomic, PositionError>;\n  }\n\n  clone(): Atomic {\n    return super.clone() as Atomic;\n  }\n\n  protected validate(opts?: FromSetupOpts): Result<undefined, PositionError> {\n    // Like chess, but allow our king to be missing.\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (this.board.king.size() > 2) return Result.err(new PositionError(IllegalSetup.Kings));\n    const otherKing = this.board.kingOf(opposite(this.turn));\n    if (!defined(otherKing)) return Result.err(new PositionError(IllegalSetup.Kings));\n    if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {\n      return Result.err(new PositionError(IllegalSetup.OppositeCheck));\n    }\n    if (SquareSet.backranks().intersects(this.board.pawn)) {\n      return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n    }\n    return opts?.ignoreImpossibleCheck ? Result.ok(undefined) : this.validateCheckers();\n  }\n\n  protected validateCheckers(): Result<undefined, PositionError> {\n    // Other king moving away can cause many checks to be given at the\n    // same time. Not checking details or even that the king is close enough.\n    return defined(this.epSquare) ? Result.ok(undefined) : super.validateCheckers();\n  }\n\n  protected kingAttackers(square: Square, attacker: Color, occupied: SquareSet): SquareSet {\n    const attackerKings = this.board.pieces(attacker, 'king');\n    if (attackerKings.isEmpty() || kingAttacks(square).intersects(attackerKings)) {\n      return SquareSet.empty();\n    }\n    return super.kingAttackers(square, attacker, occupied);\n  }\n\n  protected playCaptureAt(square: Square, captured: Piece): void {\n    super.playCaptureAt(square, captured);\n    this.board.take(square);\n    for (const explode of kingAttacks(square).intersect(this.board.occupied).diff(this.board.pawn)) {\n      const piece = this.board.take(explode);\n      if (piece && piece.role === 'rook') this.castles.discardRook(explode);\n      if (piece && piece.role === 'king') this.castles.discardSide(piece.color);\n    }\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    // Remaining material does not matter if the enemy king is already\n    // exploded.\n    if (this.board.pieces(opposite(color), 'king').isEmpty()) return false;\n\n    // Bare king cannot mate.\n    if (this.board[color].diff(this.board.king).isEmpty()) return true;\n\n    // As long as the enemy king is not alone, there is always a chance their\n    // own pieces explode next to it.\n    if (this.board[opposite(color)].diff(this.board.king).nonEmpty()) {\n      // Unless there are only bishops that cannot explode each other.\n      if (this.board.occupied.equals(this.board.bishop.union(this.board.king))) {\n        if (!this.board.bishop.intersect(this.board.white).intersects(SquareSet.darkSquares())) {\n          return !this.board.bishop.intersect(this.board.black).intersects(SquareSet.lightSquares());\n        }\n        if (!this.board.bishop.intersect(this.board.white).intersects(SquareSet.lightSquares())) {\n          return !this.board.bishop.intersect(this.board.black).intersects(SquareSet.darkSquares());\n        }\n      }\n      return false;\n    }\n\n    // Queen or pawn (future queen) can give mate against bare king.\n    if (this.board.queen.nonEmpty() || this.board.pawn.nonEmpty()) return false;\n\n    // Single knight, bishop or rook cannot mate against bare king.\n    if (this.board.knight.union(this.board.bishop).union(this.board.rook).isSingleSquare()) return true;\n\n    // If only knights, more than two are required to mate bare king.\n    if (this.board.occupied.equals(this.board.knight.union(this.board.king))) {\n      return this.board.knight.size() <= 2;\n    }\n\n    return false;\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n    let dests = SquareSet.empty();\n    for (const to of this.pseudoDests(square, ctx)) {\n      const after = this.clone();\n      after.play({ from: square, to });\n      const ourKing = after.board.kingOf(this.turn);\n      if (\n        defined(ourKing) &&\n        (!defined(after.board.kingOf(after.turn)) ||\n          after.kingAttackers(ourKing, after.turn, after.board.occupied).isEmpty())\n      ) {\n        dests = dests.with(to);\n      }\n    }\n    return dests;\n  }\n\n  isVariantEnd(): boolean {\n    return !!this.variantOutcome();\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    for (const color of COLORS) {\n      if (this.board.pieces(color, 'king').isEmpty()) return { winner: opposite(color) };\n    }\n    return;\n  }\n}\n\nexport class Antichess extends Chess {\n  protected constructor() {\n    super('antichess');\n  }\n\n  static default(): Antichess {\n    const pos = super.default();\n    pos.castles = Castles.empty();\n    return pos as Antichess;\n  }\n\n  static fromSetup(setup: Setup, opts?: FromSetupOpts): Result<Antichess, PositionError> {\n    return super.fromSetup(setup, opts).map(pos => {\n      pos.castles = Castles.empty();\n      return pos as Antichess;\n    });\n  }\n\n  clone(): Antichess {\n    return super.clone() as Antichess;\n  }\n\n  protected validate(_opts?: FromSetupOpts): Result<undefined, PositionError> {\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (SquareSet.backranks().intersects(this.board.pawn))\n      return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n    return Result.ok(undefined);\n  }\n\n  protected kingAttackers(_square: Square, _attacker: Color, _occupied: SquareSet): SquareSet {\n    return SquareSet.empty();\n  }\n\n  ctx(): Context {\n    const ctx = super.ctx();\n    const enemy = this.board[opposite(this.turn)];\n    for (const from of this.board[this.turn]) {\n      if (this.pseudoDests(from, ctx).intersects(enemy)) {\n        ctx.mustCapture = true;\n        break;\n      }\n    }\n    return ctx;\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n    const dests = this.pseudoDests(square, ctx);\n    if (!ctx.mustCapture) return dests;\n    return dests.intersect(this.board[opposite(this.turn)]);\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    if (this.board.occupied.equals(this.board.bishop)) {\n      const weSomeOnLight = this.board[color].intersects(SquareSet.lightSquares());\n      const weSomeOnDark = this.board[color].intersects(SquareSet.darkSquares());\n      const theyAllOnDark = this.board[opposite(color)].isDisjoint(SquareSet.lightSquares());\n      const theyAllOnLight = this.board[opposite(color)].isDisjoint(SquareSet.darkSquares());\n      return (weSomeOnLight && theyAllOnDark) || (weSomeOnDark && theyAllOnLight);\n    }\n    return false;\n  }\n\n  isVariantEnd(): boolean {\n    return this.board[this.turn].isEmpty();\n  }\n\n  variantOutcome(ctx?: Context): Outcome | undefined {\n    ctx = ctx || this.ctx();\n    if (ctx.variantEnd || this.isStalemate(ctx)) {\n      return { winner: this.turn };\n    }\n    return;\n  }\n}\n\nexport class KingOfTheHill extends Chess {\n  protected constructor() {\n    super('kingofthehill');\n  }\n\n  static default(): KingOfTheHill {\n    return super.default();\n  }\n\n  static fromSetup(setup: Setup, opts?: FromSetupOpts): Result<KingOfTheHill, PositionError> {\n    return super.fromSetup(setup, opts);\n  }\n\n  clone(): KingOfTheHill {\n    return super.clone() as KingOfTheHill;\n  }\n\n  hasInsufficientMaterial(_color: Color): boolean {\n    return false;\n  }\n\n  isVariantEnd(): boolean {\n    return this.board.king.intersects(SquareSet.center());\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    for (const color of COLORS) {\n      if (this.board.pieces(color, 'king').intersects(SquareSet.center())) return { winner: color };\n    }\n    return;\n  }\n}\n\nexport class ThreeCheck extends Chess {\n  protected constructor() {\n    super('3check');\n  }\n\n  static default(): ThreeCheck {\n    const pos = super.default();\n    pos.remainingChecks = RemainingChecks.default();\n    return pos;\n  }\n\n  static fromSetup(setup: Setup, opts?: FromSetupOpts): Result<ThreeCheck, PositionError> {\n    return super.fromSetup(setup, opts).map(pos => {\n      pos.remainingChecks = setup.remainingChecks ? setup.remainingChecks.clone() : RemainingChecks.default();\n      return pos;\n    });\n  }\n\n  clone(): ThreeCheck {\n    return super.clone() as ThreeCheck;\n  }\n\n  hasInsufficientMaterial(color: Color): boolean {\n    return this.board.pieces(color, 'king').equals(this.board[color]);\n  }\n\n  isVariantEnd(): boolean {\n    return !!this.remainingChecks && (this.remainingChecks.white <= 0 || this.remainingChecks.black <= 0);\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    if (this.remainingChecks) {\n      for (const color of COLORS) {\n        if (this.remainingChecks[color] <= 0) return { winner: color };\n      }\n    }\n    return;\n  }\n}\n\nexport class RacingKings extends Chess {\n  protected constructor() {\n    super('racingkings');\n  }\n\n  static default(): RacingKings {\n    const pos = new this();\n    pos.board = Board.racingKings();\n    pos.pockets = undefined;\n    pos.turn = 'white';\n    pos.castles = Castles.empty();\n    pos.epSquare = undefined;\n    pos.remainingChecks = undefined;\n    pos.halfmoves = 0;\n    pos.fullmoves = 1;\n    return pos;\n  }\n\n  static fromSetup(setup: Setup, opts?: FromSetupOpts): Result<RacingKings, PositionError> {\n    return super.fromSetup(setup, opts).map(pos => {\n      pos.castles = Castles.empty();\n      return pos as RacingKings;\n    });\n  }\n\n  protected validate(opts?: FromSetupOpts): Result<undefined, PositionError> {\n    if (this.isCheck() || this.board.pawn.nonEmpty()) return Result.err(new PositionError(IllegalSetup.Variant));\n    return super.validate(opts);\n  }\n\n  clone(): RacingKings {\n    return super.clone() as RacingKings;\n  }\n\n  dests(square: Square, ctx?: Context): SquareSet {\n    ctx = ctx || this.ctx();\n\n    // Kings cannot give check.\n    if (square === ctx.king) return super.dests(square, ctx);\n\n    // Do not allow giving check.\n    let dests = SquareSet.empty();\n    for (const to of super.dests(square, ctx)) {\n      // Valid, because there are no promotions (or even pawns).\n      const move = { from: square, to };\n      const after = this.clone();\n      after.play(move);\n      if (!after.isCheck()) dests = dests.with(to);\n    }\n    return dests;\n  }\n\n  hasInsufficientMaterial(_color: Color): boolean {\n    return false;\n  }\n\n  isVariantEnd(): boolean {\n    const goal = SquareSet.fromRank(7);\n    const inGoal = this.board.king.intersect(goal);\n    if (inGoal.isEmpty()) return false;\n    if (this.turn === 'white' || inGoal.intersects(this.board.black)) return true;\n\n    // White has reached the backrank. Check if black can catch up.\n    const blackKing = this.board.kingOf('black');\n    if (defined(blackKing)) {\n      const occ = this.board.occupied.without(blackKing);\n      for (const target of kingAttacks(blackKing).intersect(goal).diff(this.board.black)) {\n        if (this.kingAttackers(target, 'white', occ).isEmpty()) return false;\n      }\n    }\n    return true;\n  }\n\n  variantOutcome(ctx?: Context): Outcome | undefined {\n    if (ctx ? !ctx.variantEnd : !this.isVariantEnd()) return;\n    const goal = SquareSet.fromRank(7);\n    const blackInGoal = this.board.pieces('black', 'king').intersects(goal);\n    const whiteInGoal = this.board.pieces('white', 'king').intersects(goal);\n    if (blackInGoal && !whiteInGoal) return { winner: 'black' };\n    if (whiteInGoal && !blackInGoal) return { winner: 'white' };\n    return { winner: undefined };\n  }\n}\n\nexport class Horde extends Chess {\n  protected constructor() {\n    super('horde');\n  }\n\n  static default(): Horde {\n    const pos = new this();\n    pos.board = Board.horde();\n    pos.pockets = undefined;\n    pos.turn = 'white';\n    pos.castles = Castles.default();\n    pos.castles.discardSide('white');\n    pos.epSquare = undefined;\n    pos.remainingChecks = undefined;\n    pos.halfmoves = 0;\n    pos.fullmoves = 1;\n    return pos;\n  }\n\n  static fromSetup(setup: Setup, opts?: FromSetupOpts): Result<Horde, PositionError> {\n    return super.fromSetup(setup, opts) as Result<Horde, PositionError>;\n  }\n\n  protected validate(opts?: FromSetupOpts): Result<undefined, PositionError> {\n    if (this.board.occupied.isEmpty()) return Result.err(new PositionError(IllegalSetup.Empty));\n    if (!this.board.king.isSingleSquare()) return Result.err(new PositionError(IllegalSetup.Kings));\n    if (!this.board.king.diff(this.board.promoted).isSingleSquare())\n      return Result.err(new PositionError(IllegalSetup.Kings));\n\n    const otherKing = this.board.kingOf(opposite(this.turn));\n    if (defined(otherKing) && this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty())\n      return Result.err(new PositionError(IllegalSetup.OppositeCheck));\n    for (const color of COLORS) {\n      if (this.board.pieces(color, 'pawn').intersects(SquareSet.backrank(opposite(color)))) {\n        return Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n      }\n    }\n    return opts?.ignoreImpossibleCheck ? Result.ok(undefined) : this.validateCheckers();\n  }\n\n  clone(): Horde {\n    return super.clone() as Horde;\n  }\n\n  hasInsufficientMaterial(_color: Color): boolean {\n    // TODO: Could detect cases where the horde cannot mate.\n    return false;\n  }\n\n  isVariantEnd(): boolean {\n    return this.board.white.isEmpty() || this.board.black.isEmpty();\n  }\n\n  variantOutcome(_ctx?: Context): Outcome | undefined {\n    if (this.board.white.isEmpty()) return { winner: 'black' };\n    if (this.board.black.isEmpty()) return { winner: 'white' };\n    return;\n  }\n}\n\nexport function defaultPosition(rules: Rules): Position {\n  switch (rules) {\n    case 'chess':\n      return Chess.default();\n    case 'antichess':\n      return Antichess.default();\n    case 'atomic':\n      return Atomic.default();\n    case 'horde':\n      return Horde.default();\n    case 'racingkings':\n      return RacingKings.default();\n    case 'kingofthehill':\n      return KingOfTheHill.default();\n    case '3check':\n      return ThreeCheck.default();\n    case 'crazyhouse':\n      return Crazyhouse.default();\n  }\n}\n\nexport function setupPosition(rules: Rules, setup: Setup, opts?: FromSetupOpts): Result<Position, PositionError> {\n  switch (rules) {\n    case 'chess':\n      return Chess.fromSetup(setup, opts);\n    case 'antichess':\n      return Antichess.fromSetup(setup, opts);\n    case 'atomic':\n      return Atomic.fromSetup(setup, opts);\n    case 'horde':\n      return Horde.fromSetup(setup, opts);\n    case 'racingkings':\n      return RacingKings.fromSetup(setup, opts);\n    case 'kingofthehill':\n      return KingOfTheHill.fromSetup(setup, opts);\n    case '3check':\n      return ThreeCheck.fromSetup(setup, opts);\n    case 'crazyhouse':\n      return Crazyhouse.fromSetup(setup, opts);\n  }\n}\n"],
  "mappings": "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",
  "names": ["square", "piece", "IllegalSetup", "square", "board", "dests", "piece", "square", "piece", "board", "dests", "n", "board", "match", "board", "square", "piece", "dests"]
}
