import {
  COLORS,
  FILE_NAMES,
  ROLES,
  charToRole,
  defined,
  makeSquare,
  parseSquare,
  roleToChar,
  squareFile
} from "./chunk-3THGZOZQ.js";
import {
  __export
} from "./chunk-5WWUZCGV.js";

// node_modules/chessops/fen.js
var fen_exports = {};
__export(fen_exports, {
  EMPTY_BOARD_FEN: () => EMPTY_BOARD_FEN,
  EMPTY_EPD: () => EMPTY_EPD,
  EMPTY_FEN: () => EMPTY_FEN,
  FenError: () => FenError,
  INITIAL_BOARD_FEN: () => INITIAL_BOARD_FEN,
  INITIAL_EPD: () => INITIAL_EPD,
  INITIAL_FEN: () => INITIAL_FEN,
  InvalidFen: () => InvalidFen,
  makeBoardFen: () => makeBoardFen,
  makeCastlingFen: () => makeCastlingFen,
  makeFen: () => makeFen,
  makePiece: () => makePiece,
  makePocket: () => makePocket,
  makePockets: () => makePockets,
  makeRemainingChecks: () => makeRemainingChecks,
  parseBoardFen: () => parseBoardFen,
  parseCastlingFen: () => parseCastlingFen,
  parseFen: () => parseFen,
  parsePiece: () => parsePiece,
  parsePockets: () => parsePockets,
  parseRemainingChecks: () => parseRemainingChecks
});

// node_modules/@badrap/result/dist/index.mjs
function r(r2, n2) {
  r2.prototype = Object.create(n2.prototype), r2.prototype.constructor = r2, r2.__proto__ = n2;
}
var n;
var t = function() {
  function r2() {
  }
  var t2 = r2.prototype;
  return t2.unwrap = function(r3, t3) {
    var o2 = this._chain(function(t4) {
      return n.ok(r3 ? r3(t4) : t4);
    }, function(r4) {
      return t3 ? n.ok(t3(r4)) : n.err(r4);
    });
    if (o2.isErr)
      throw o2.error;
    return o2.value;
  }, t2.map = function(r3, t3) {
    return this._chain(function(t4) {
      return n.ok(r3(t4));
    }, function(r4) {
      return n.err(t3 ? t3(r4) : r4);
    });
  }, t2.chain = function(r3, t3) {
    return this._chain(r3, t3 || function(r4) {
      return n.err(r4);
    });
  }, r2;
}();
var o = function(n2) {
  function t2(r2) {
    var t3;
    return (t3 = n2.call(this) || this).value = r2, t3.isOk = true, t3.isErr = false, t3;
  }
  return r(t2, n2), t2.prototype._chain = function(r2, n3) {
    return r2(this.value);
  }, t2;
}(t);
var e = function(n2) {
  function t2(r2) {
    var t3;
    return (t3 = n2.call(this) || this).error = r2, t3.isOk = false, t3.isErr = true, t3;
  }
  return r(t2, n2), t2.prototype._chain = function(r2, n3) {
    return n3(this.error);
  }, t2;
}(t);
!function(r2) {
  r2.ok = function(r3) {
    return new o(r3);
  }, r2.err = function(r3) {
    return new e(r3 || new Error());
  }, r2.all = function(n2) {
    if (Array.isArray(n2)) {
      for (var t2 = [], o2 = 0; o2 < n2.length; o2++) {
        var e2 = n2[o2];
        if (e2.isErr)
          return e2;
        t2.push(e2.value);
      }
      return r2.ok(t2);
    }
    for (var u = {}, i = Object.keys(n2), c = 0; c < i.length; c++) {
      var a = n2[i[c]];
      if (a.isErr)
        return a;
      u[i[c]] = a.value;
    }
    return r2.ok(u);
  };
}(n || (n = {}));

// node_modules/chessops/squareSet.js
function popcnt32(n2) {
  n2 = n2 - (n2 >>> 1 & 1431655765);
  n2 = (n2 & 858993459) + (n2 >>> 2 & 858993459);
  return Math.imul(n2 + (n2 >>> 4) & 252645135, 16843009) >> 24;
}
function bswap32(n2) {
  n2 = n2 >>> 8 & 16711935 | (n2 & 16711935) << 8;
  return n2 >>> 16 & 65535 | (n2 & 65535) << 16;
}
function rbit32(n2) {
  n2 = n2 >>> 1 & 1431655765 | (n2 & 1431655765) << 1;
  n2 = n2 >>> 2 & 858993459 | (n2 & 858993459) << 2;
  n2 = n2 >>> 4 & 252645135 | (n2 & 252645135) << 4;
  return bswap32(n2);
}
var SquareSet = class _SquareSet {
  constructor(lo, hi) {
    this.lo = lo;
    this.hi = hi;
    this.lo = lo | 0;
    this.hi = hi | 0;
  }
  static fromSquare(square) {
    return square >= 32 ? new _SquareSet(0, 1 << square - 32) : new _SquareSet(1 << square, 0);
  }
  static fromRank(rank) {
    return new _SquareSet(255, 0).shl64(8 * rank);
  }
  static fromFile(file) {
    return new _SquareSet(16843009 << file, 16843009 << file);
  }
  static empty() {
    return new _SquareSet(0, 0);
  }
  static full() {
    return new _SquareSet(4294967295, 4294967295);
  }
  static corners() {
    return new _SquareSet(129, 2164260864);
  }
  static center() {
    return new _SquareSet(402653184, 24);
  }
  static backranks() {
    return new _SquareSet(255, 4278190080);
  }
  static backrank(color) {
    return color === "white" ? new _SquareSet(255, 0) : new _SquareSet(0, 4278190080);
  }
  static lightSquares() {
    return new _SquareSet(1437226410, 1437226410);
  }
  static darkSquares() {
    return new _SquareSet(2857740885, 2857740885);
  }
  complement() {
    return new _SquareSet(~this.lo, ~this.hi);
  }
  xor(other) {
    return new _SquareSet(this.lo ^ other.lo, this.hi ^ other.hi);
  }
  union(other) {
    return new _SquareSet(this.lo | other.lo, this.hi | other.hi);
  }
  intersect(other) {
    return new _SquareSet(this.lo & other.lo, this.hi & other.hi);
  }
  diff(other) {
    return new _SquareSet(this.lo & ~other.lo, this.hi & ~other.hi);
  }
  intersects(other) {
    return this.intersect(other).nonEmpty();
  }
  isDisjoint(other) {
    return this.intersect(other).isEmpty();
  }
  supersetOf(other) {
    return other.diff(this).isEmpty();
  }
  subsetOf(other) {
    return this.diff(other).isEmpty();
  }
  shr64(shift) {
    if (shift >= 64)
      return _SquareSet.empty();
    if (shift >= 32)
      return new _SquareSet(this.hi >>> shift - 32, 0);
    if (shift > 0)
      return new _SquareSet(this.lo >>> shift ^ this.hi << 32 - shift, this.hi >>> shift);
    return this;
  }
  shl64(shift) {
    if (shift >= 64)
      return _SquareSet.empty();
    if (shift >= 32)
      return new _SquareSet(0, this.lo << shift - 32);
    if (shift > 0)
      return new _SquareSet(this.lo << shift, this.hi << shift ^ this.lo >>> 32 - shift);
    return this;
  }
  bswap64() {
    return new _SquareSet(bswap32(this.hi), bswap32(this.lo));
  }
  rbit64() {
    return new _SquareSet(rbit32(this.hi), rbit32(this.lo));
  }
  minus64(other) {
    const lo = this.lo - other.lo;
    const c = (lo & other.lo & 1) + (other.lo >>> 1) + (lo >>> 1) >>> 31;
    return new _SquareSet(lo, this.hi - (other.hi + c));
  }
  equals(other) {
    return this.lo === other.lo && this.hi === other.hi;
  }
  size() {
    return popcnt32(this.lo) + popcnt32(this.hi);
  }
  isEmpty() {
    return this.lo === 0 && this.hi === 0;
  }
  nonEmpty() {
    return this.lo !== 0 || this.hi !== 0;
  }
  has(square) {
    return (square >= 32 ? this.hi & 1 << square - 32 : this.lo & 1 << square) !== 0;
  }
  set(square, on) {
    return on ? this.with(square) : this.without(square);
  }
  with(square) {
    return square >= 32 ? new _SquareSet(this.lo, this.hi | 1 << square - 32) : new _SquareSet(this.lo | 1 << square, this.hi);
  }
  without(square) {
    return square >= 32 ? new _SquareSet(this.lo, this.hi & ~(1 << square - 32)) : new _SquareSet(this.lo & ~(1 << square), this.hi);
  }
  toggle(square) {
    return square >= 32 ? new _SquareSet(this.lo, this.hi ^ 1 << square - 32) : new _SquareSet(this.lo ^ 1 << square, this.hi);
  }
  last() {
    if (this.hi !== 0)
      return 63 - Math.clz32(this.hi);
    if (this.lo !== 0)
      return 31 - Math.clz32(this.lo);
    return;
  }
  first() {
    if (this.lo !== 0)
      return 31 - Math.clz32(this.lo & -this.lo);
    if (this.hi !== 0)
      return 63 - Math.clz32(this.hi & -this.hi);
    return;
  }
  withoutFirst() {
    if (this.lo !== 0)
      return new _SquareSet(this.lo & this.lo - 1, this.hi);
    return new _SquareSet(0, this.hi & this.hi - 1);
  }
  moreThanOne() {
    return this.hi !== 0 && this.lo !== 0 || (this.lo & this.lo - 1) !== 0 || (this.hi & this.hi - 1) !== 0;
  }
  singleSquare() {
    return this.moreThanOne() ? void 0 : this.last();
  }
  isSingleSquare() {
    return this.nonEmpty() && !this.moreThanOne();
  }
  *[Symbol.iterator]() {
    let lo = this.lo;
    let hi = this.hi;
    while (lo !== 0) {
      const idx = 31 - Math.clz32(lo & -lo);
      lo ^= 1 << idx;
      yield idx;
    }
    while (hi !== 0) {
      const idx = 31 - Math.clz32(hi & -hi);
      hi ^= 1 << idx;
      yield 32 + idx;
    }
  }
  *reversed() {
    let lo = this.lo;
    let hi = this.hi;
    while (hi !== 0) {
      const idx = 31 - Math.clz32(hi);
      hi ^= 1 << idx;
      yield 32 + idx;
    }
    while (lo !== 0) {
      const idx = 31 - Math.clz32(lo);
      lo ^= 1 << idx;
      yield idx;
    }
  }
};

// node_modules/chessops/board.js
var Board = class _Board {
  constructor() {
  }
  static default() {
    const board = new _Board();
    board.reset();
    return board;
  }
  static racingKings() {
    const board = new _Board();
    board.occupied = new SquareSet(65535, 0);
    board.promoted = SquareSet.empty();
    board.white = new SquareSet(61680, 0);
    board.black = new SquareSet(3855, 0);
    board.pawn = SquareSet.empty();
    board.knight = new SquareSet(6168, 0);
    board.bishop = new SquareSet(9252, 0);
    board.rook = new SquareSet(16962, 0);
    board.queen = new SquareSet(129, 0);
    board.king = new SquareSet(33024, 0);
    return board;
  }
  static horde() {
    const board = new _Board();
    board.occupied = new SquareSet(4294967295, 4294901862);
    board.promoted = SquareSet.empty();
    board.white = new SquareSet(4294967295, 102);
    board.black = new SquareSet(0, 4294901760);
    board.pawn = new SquareSet(4294967295, 16711782);
    board.knight = new SquareSet(0, 1107296256);
    board.bishop = new SquareSet(0, 603979776);
    board.rook = new SquareSet(0, 2164260864);
    board.queen = new SquareSet(0, 134217728);
    board.king = new SquareSet(0, 268435456);
    return board;
  }
  /**
   * Resets all pieces to the default starting position for standard chess.
   */
  reset() {
    this.occupied = new SquareSet(65535, 4294901760);
    this.promoted = SquareSet.empty();
    this.white = new SquareSet(65535, 0);
    this.black = new SquareSet(0, 4294901760);
    this.pawn = new SquareSet(65280, 16711680);
    this.knight = new SquareSet(66, 1107296256);
    this.bishop = new SquareSet(36, 603979776);
    this.rook = new SquareSet(129, 2164260864);
    this.queen = new SquareSet(8, 134217728);
    this.king = new SquareSet(16, 268435456);
  }
  static empty() {
    const board = new _Board();
    board.clear();
    return board;
  }
  clear() {
    this.occupied = SquareSet.empty();
    this.promoted = SquareSet.empty();
    for (const color of COLORS)
      this[color] = SquareSet.empty();
    for (const role of ROLES)
      this[role] = SquareSet.empty();
  }
  clone() {
    const board = new _Board();
    board.occupied = this.occupied;
    board.promoted = this.promoted;
    for (const color of COLORS)
      board[color] = this[color];
    for (const role of ROLES)
      board[role] = this[role];
    return board;
  }
  equalsIgnorePromoted(other) {
    if (!this.white.equals(other.white))
      return false;
    return ROLES.every((role) => this[role].equals(other[role]));
  }
  equals(other) {
    return this.equalsIgnorePromoted(other) && this.promoted.equals(other.promoted);
  }
  getColor(square) {
    if (this.white.has(square))
      return "white";
    if (this.black.has(square))
      return "black";
    return;
  }
  getRole(square) {
    for (const role of ROLES) {
      if (this[role].has(square))
        return role;
    }
    return;
  }
  get(square) {
    const color = this.getColor(square);
    if (!color)
      return;
    const role = this.getRole(square);
    const promoted = this.promoted.has(square);
    return { color, role, promoted };
  }
  /**
   * Removes and returns the piece from the given `square`, if any.
   */
  take(square) {
    const piece = this.get(square);
    if (piece) {
      this.occupied = this.occupied.without(square);
      this[piece.color] = this[piece.color].without(square);
      this[piece.role] = this[piece.role].without(square);
      if (piece.promoted)
        this.promoted = this.promoted.without(square);
    }
    return piece;
  }
  /**
   * Put `piece` onto `square`, potentially replacing an existing piece.
   * Returns the existing piece, if any.
   */
  set(square, piece) {
    const old = this.take(square);
    this.occupied = this.occupied.with(square);
    this[piece.color] = this[piece.color].with(square);
    this[piece.role] = this[piece.role].with(square);
    if (piece.promoted)
      this.promoted = this.promoted.with(square);
    return old;
  }
  has(square) {
    return this.occupied.has(square);
  }
  *[Symbol.iterator]() {
    for (const square of this.occupied) {
      yield [square, this.get(square)];
    }
  }
  pieces(color, role) {
    return this[color].intersect(this[role]);
  }
  rooksAndQueens() {
    return this.rook.union(this.queen);
  }
  bishopsAndQueens() {
    return this.bishop.union(this.queen);
  }
  /**
   * Finds the unique unpromoted king of the given `color`, if any.
   */
  kingOf(color) {
    return this.king.intersect(this[color]).diff(this.promoted).singleSquare();
  }
};

// node_modules/chessops/setup.js
var MaterialSide = class _MaterialSide {
  constructor() {
  }
  static empty() {
    const m = new _MaterialSide();
    for (const role of ROLES)
      m[role] = 0;
    return m;
  }
  static fromBoard(board, color) {
    const m = new _MaterialSide();
    for (const role of ROLES)
      m[role] = board.pieces(color, role).size();
    return m;
  }
  clone() {
    const m = new _MaterialSide();
    for (const role of ROLES)
      m[role] = this[role];
    return m;
  }
  equals(other) {
    return ROLES.every((role) => this[role] === other[role]);
  }
  add(other) {
    const m = new _MaterialSide();
    for (const role of ROLES)
      m[role] = this[role] + other[role];
    return m;
  }
  nonEmpty() {
    return ROLES.some((role) => this[role] > 0);
  }
  isEmpty() {
    return !this.nonEmpty();
  }
  hasPawns() {
    return this.pawn > 0;
  }
  hasNonPawns() {
    return this.knight > 0 || this.bishop > 0 || this.rook > 0 || this.queen > 0 || this.king > 0;
  }
  count() {
    return this.pawn + this.knight + this.bishop + this.rook + this.queen + this.king;
  }
};
var Material = class _Material {
  constructor(white, black) {
    this.white = white;
    this.black = black;
  }
  static empty() {
    return new _Material(MaterialSide.empty(), MaterialSide.empty());
  }
  static fromBoard(board) {
    return new _Material(MaterialSide.fromBoard(board, "white"), MaterialSide.fromBoard(board, "black"));
  }
  clone() {
    return new _Material(this.white.clone(), this.black.clone());
  }
  equals(other) {
    return this.white.equals(other.white) && this.black.equals(other.black);
  }
  add(other) {
    return new _Material(this.white.add(other.white), this.black.add(other.black));
  }
  count() {
    return this.white.count() + this.black.count();
  }
  isEmpty() {
    return this.white.isEmpty() && this.black.isEmpty();
  }
  nonEmpty() {
    return !this.isEmpty();
  }
  hasPawns() {
    return this.white.hasPawns() || this.black.hasPawns();
  }
  hasNonPawns() {
    return this.white.hasNonPawns() || this.black.hasNonPawns();
  }
};
var RemainingChecks = class _RemainingChecks {
  constructor(white, black) {
    this.white = white;
    this.black = black;
  }
  static default() {
    return new _RemainingChecks(3, 3);
  }
  clone() {
    return new _RemainingChecks(this.white, this.black);
  }
  equals(other) {
    return this.white === other.white && this.black === other.black;
  }
};
function defaultSetup() {
  return {
    board: Board.default(),
    pockets: void 0,
    turn: "white",
    unmovedRooks: SquareSet.corners(),
    epSquare: void 0,
    remainingChecks: void 0,
    halfmoves: 0,
    fullmoves: 1
  };
}

// node_modules/chessops/fen.js
var INITIAL_BOARD_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR";
var INITIAL_EPD = INITIAL_BOARD_FEN + " w KQkq -";
var INITIAL_FEN = INITIAL_EPD + " 0 1";
var EMPTY_BOARD_FEN = "8/8/8/8/8/8/8/8";
var EMPTY_EPD = EMPTY_BOARD_FEN + " w - -";
var EMPTY_FEN = EMPTY_EPD + " 0 1";
var InvalidFen;
(function(InvalidFen2) {
  InvalidFen2["Fen"] = "ERR_FEN";
  InvalidFen2["Board"] = "ERR_BOARD";
  InvalidFen2["Pockets"] = "ERR_POCKETS";
  InvalidFen2["Turn"] = "ERR_TURN";
  InvalidFen2["Castling"] = "ERR_CASTLING";
  InvalidFen2["EpSquare"] = "ERR_EP_SQUARE";
  InvalidFen2["RemainingChecks"] = "ERR_REMAINING_CHECKS";
  InvalidFen2["Halfmoves"] = "ERR_HALFMOVES";
  InvalidFen2["Fullmoves"] = "ERR_FULLMOVES";
})(InvalidFen || (InvalidFen = {}));
var FenError = class extends Error {
};
function nthIndexOf(haystack, needle, n2) {
  let index = haystack.indexOf(needle);
  while (n2-- > 0) {
    if (index === -1)
      break;
    index = haystack.indexOf(needle, index + needle.length);
  }
  return index;
}
function parseSmallUint(str) {
  return /^\d{1,4}$/.test(str) ? parseInt(str, 10) : void 0;
}
function charToPiece(ch) {
  const role = charToRole(ch);
  return role && { role, color: ch.toLowerCase() === ch ? "black" : "white" };
}
function parseBoardFen(boardPart) {
  const board = Board.empty();
  let rank = 7;
  let file = 0;
  for (let i = 0; i < boardPart.length; i++) {
    const c = boardPart[i];
    if (c === "/" && file === 8) {
      file = 0;
      rank--;
    } else {
      const step = parseInt(c, 10);
      if (step > 0)
        file += step;
      else {
        if (file >= 8 || rank < 0)
          return n.err(new FenError(InvalidFen.Board));
        const square = file + rank * 8;
        const piece = charToPiece(c);
        if (!piece)
          return n.err(new FenError(InvalidFen.Board));
        if (boardPart[i + 1] === "~") {
          piece.promoted = true;
          i++;
        }
        board.set(square, piece);
        file++;
      }
    }
  }
  if (rank !== 0 || file !== 8)
    return n.err(new FenError(InvalidFen.Board));
  return n.ok(board);
}
function parsePockets(pocketPart) {
  if (pocketPart.length > 64)
    return n.err(new FenError(InvalidFen.Pockets));
  const pockets = Material.empty();
  for (const c of pocketPart) {
    const piece = charToPiece(c);
    if (!piece)
      return n.err(new FenError(InvalidFen.Pockets));
    pockets[piece.color][piece.role]++;
  }
  return n.ok(pockets);
}
function parseCastlingFen(board, castlingPart) {
  let unmovedRooks = SquareSet.empty();
  if (castlingPart === "-")
    return n.ok(unmovedRooks);
  for (const c of castlingPart) {
    const lower = c.toLowerCase();
    const color = c === lower ? "black" : "white";
    const backrank = SquareSet.backrank(color).intersect(board[color]);
    let candidates;
    if (lower === "q")
      candidates = backrank;
    else if (lower === "k")
      candidates = backrank.reversed();
    else if ("a" <= lower && lower <= "h")
      candidates = SquareSet.fromSquare(lower.charCodeAt(0) - "a".charCodeAt(0)).intersect(backrank);
    else
      return n.err(new FenError(InvalidFen.Castling));
    for (const square of candidates) {
      if (board.king.has(square) && !board.promoted.has(square))
        break;
      if (board.rook.has(square)) {
        unmovedRooks = unmovedRooks.with(square);
        break;
      }
    }
  }
  if (COLORS.some((color) => SquareSet.backrank(color).intersect(unmovedRooks).size() > 2))
    return n.err(new FenError(InvalidFen.Castling));
  return n.ok(unmovedRooks);
}
function parseRemainingChecks(part) {
  const parts = part.split("+");
  if (parts.length === 3 && parts[0] === "") {
    const white = parseSmallUint(parts[1]);
    const black = parseSmallUint(parts[2]);
    if (!defined(white) || white > 3 || !defined(black) || black > 3)
      return n.err(new FenError(InvalidFen.RemainingChecks));
    return n.ok(new RemainingChecks(3 - white, 3 - black));
  } else if (parts.length === 2) {
    const white = parseSmallUint(parts[0]);
    const black = parseSmallUint(parts[1]);
    if (!defined(white) || white > 3 || !defined(black) || black > 3)
      return n.err(new FenError(InvalidFen.RemainingChecks));
    return n.ok(new RemainingChecks(white, black));
  } else
    return n.err(new FenError(InvalidFen.RemainingChecks));
}
function parseFen(fen) {
  const parts = fen.split(/[\s_]+/);
  const boardPart = parts.shift();
  let board, pockets = n.ok(void 0);
  if (boardPart.endsWith("]")) {
    const pocketStart = boardPart.indexOf("[");
    if (pocketStart === -1)
      return n.err(new FenError(InvalidFen.Fen));
    board = parseBoardFen(boardPart.substr(0, pocketStart));
    pockets = parsePockets(boardPart.substr(pocketStart + 1, boardPart.length - 1 - pocketStart - 1));
  } else {
    const pocketStart = nthIndexOf(boardPart, "/", 7);
    if (pocketStart === -1)
      board = parseBoardFen(boardPart);
    else {
      board = parseBoardFen(boardPart.substr(0, pocketStart));
      pockets = parsePockets(boardPart.substr(pocketStart + 1));
    }
  }
  let turn;
  const turnPart = parts.shift();
  if (!defined(turnPart) || turnPart === "w")
    turn = "white";
  else if (turnPart === "b")
    turn = "black";
  else
    return n.err(new FenError(InvalidFen.Turn));
  return board.chain((board2) => {
    const castlingPart = parts.shift();
    const unmovedRooks = defined(castlingPart) ? parseCastlingFen(board2, castlingPart) : n.ok(SquareSet.empty());
    const epPart = parts.shift();
    let epSquare;
    if (defined(epPart) && epPart !== "-") {
      epSquare = parseSquare(epPart);
      if (!defined(epSquare))
        return n.err(new FenError(InvalidFen.EpSquare));
    }
    let halfmovePart = parts.shift();
    let earlyRemainingChecks;
    if (defined(halfmovePart) && halfmovePart.includes("+")) {
      earlyRemainingChecks = parseRemainingChecks(halfmovePart);
      halfmovePart = parts.shift();
    }
    const halfmoves = defined(halfmovePart) ? parseSmallUint(halfmovePart) : 0;
    if (!defined(halfmoves))
      return n.err(new FenError(InvalidFen.Halfmoves));
    const fullmovesPart = parts.shift();
    const fullmoves = defined(fullmovesPart) ? parseSmallUint(fullmovesPart) : 1;
    if (!defined(fullmoves))
      return n.err(new FenError(InvalidFen.Fullmoves));
    const remainingChecksPart = parts.shift();
    let remainingChecks = n.ok(void 0);
    if (defined(remainingChecksPart)) {
      if (defined(earlyRemainingChecks))
        return n.err(new FenError(InvalidFen.RemainingChecks));
      remainingChecks = parseRemainingChecks(remainingChecksPart);
    } else if (defined(earlyRemainingChecks)) {
      remainingChecks = earlyRemainingChecks;
    }
    if (parts.length > 0)
      return n.err(new FenError(InvalidFen.Fen));
    return pockets.chain((pockets2) => unmovedRooks.chain((unmovedRooks2) => remainingChecks.map((remainingChecks2) => {
      return {
        board: board2,
        pockets: pockets2,
        turn,
        unmovedRooks: unmovedRooks2,
        remainingChecks: remainingChecks2,
        epSquare,
        halfmoves,
        fullmoves: Math.max(1, fullmoves)
      };
    })));
  });
}
function parsePiece(str) {
  if (!str)
    return;
  const piece = charToPiece(str[0]);
  if (!piece)
    return;
  if (str.length === 2 && str[1] === "~")
    piece.promoted = true;
  else if (str.length > 1)
    return;
  return piece;
}
function makePiece(piece, opts) {
  let r2 = roleToChar(piece.role);
  if (piece.color === "white")
    r2 = r2.toUpperCase();
  if ((opts === null || opts === void 0 ? void 0 : opts.promoted) && piece.promoted)
    r2 += "~";
  return r2;
}
function makeBoardFen(board, opts) {
  let fen = "";
  let empty = 0;
  for (let rank = 7; rank >= 0; rank--) {
    for (let file = 0; file < 8; file++) {
      const square = file + rank * 8;
      const piece = board.get(square);
      if (!piece)
        empty++;
      else {
        if (empty > 0) {
          fen += empty;
          empty = 0;
        }
        fen += makePiece(piece, opts);
      }
      if (file === 7) {
        if (empty > 0) {
          fen += empty;
          empty = 0;
        }
        if (rank !== 0)
          fen += "/";
      }
    }
  }
  return fen;
}
function makePocket(material) {
  return ROLES.map((role) => roleToChar(role).repeat(material[role])).join("");
}
function makePockets(pocket) {
  return makePocket(pocket.white).toUpperCase() + makePocket(pocket.black);
}
function makeCastlingFen(board, unmovedRooks, opts) {
  const shredder = opts === null || opts === void 0 ? void 0 : opts.shredder;
  let fen = "";
  for (const color of COLORS) {
    const backrank = SquareSet.backrank(color);
    const king = board.kingOf(color);
    if (!defined(king) || !backrank.has(king))
      continue;
    const candidates = board.pieces(color, "rook").intersect(backrank);
    for (const rook of unmovedRooks.intersect(candidates).reversed()) {
      if (!shredder && rook === candidates.first() && rook < king) {
        fen += color === "white" ? "Q" : "q";
      } else if (!shredder && rook === candidates.last() && king < rook) {
        fen += color === "white" ? "K" : "k";
      } else {
        const file = FILE_NAMES[squareFile(rook)];
        fen += color === "white" ? file.toUpperCase() : file;
      }
    }
  }
  return fen || "-";
}
function makeRemainingChecks(checks) {
  return `${checks.white}+${checks.black}`;
}
function makeFen(setup, opts) {
  return [
    makeBoardFen(setup.board, opts) + (setup.pockets ? `[${makePockets(setup.pockets)}]` : ""),
    setup.turn[0],
    makeCastlingFen(setup.board, setup.unmovedRooks, opts),
    defined(setup.epSquare) ? makeSquare(setup.epSquare) : "-",
    ...setup.remainingChecks ? [makeRemainingChecks(setup.remainingChecks)] : [],
    ...(opts === null || opts === void 0 ? void 0 : opts.epd) ? [] : [Math.max(0, Math.min(setup.halfmoves, 9999)), Math.max(1, Math.min(setup.fullmoves, 9999))]
  ].join(" ");
}

export {
  SquareSet,
  Board,
  MaterialSide,
  Material,
  RemainingChecks,
  defaultSetup,
  n,
  INITIAL_BOARD_FEN,
  INITIAL_EPD,
  INITIAL_FEN,
  EMPTY_BOARD_FEN,
  EMPTY_EPD,
  EMPTY_FEN,
  InvalidFen,
  FenError,
  parseBoardFen,
  parsePockets,
  parseCastlingFen,
  parseRemainingChecks,
  parseFen,
  parsePiece,
  makePiece,
  makeBoardFen,
  makePocket,
  makePockets,
  makeCastlingFen,
  makeRemainingChecks,
  makeFen,
  fen_exports
};
//# sourceMappingURL=chunk-CRQYWGHV.js.map
