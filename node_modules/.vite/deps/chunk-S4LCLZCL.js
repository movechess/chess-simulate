// node_modules/chessground/types.js
var colors = ["white", "black"];
var files = ["a", "b", "c", "d", "e", "f", "g", "h"];
var ranks = ["1", "2", "3", "4", "5", "6", "7", "8"];

// node_modules/chessground/util.js
var invRanks = [...ranks].reverse();
var allKeys = Array.prototype.concat(...files.map((c) => ranks.map((r) => c + r)));
var pos2key = (pos) => allKeys[8 * pos[0] + pos[1]];
var key2pos = (k) => [k.charCodeAt(0) - 97, k.charCodeAt(1) - 49];
var allPos = allKeys.map(key2pos);
function memo(f) {
  let v;
  const ret = () => {
    if (v === void 0)
      v = f();
    return v;
  };
  ret.clear = () => {
    v = void 0;
  };
  return ret;
}
var timer = () => {
  let startAt;
  return {
    start() {
      startAt = performance.now();
    },
    cancel() {
      startAt = void 0;
    },
    stop() {
      if (!startAt)
        return 0;
      const time = performance.now() - startAt;
      startAt = void 0;
      return time;
    }
  };
};
var opposite = (c) => c === "white" ? "black" : "white";
var distanceSq = (pos1, pos2) => {
  const dx = pos1[0] - pos2[0], dy = pos1[1] - pos2[1];
  return dx * dx + dy * dy;
};
var samePiece = (p1, p2) => p1.role === p2.role && p1.color === p2.color;
var posToTranslate = (bounds) => (pos, asWhite) => [(asWhite ? pos[0] : 7 - pos[0]) * bounds.width / 8, (asWhite ? 7 - pos[1] : pos[1]) * bounds.height / 8];
var translate = (el, pos) => {
  el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;
};
var translateAndScale = (el, pos, scale = 1) => {
  el.style.transform = `translate(${pos[0]}px,${pos[1]}px) scale(${scale})`;
};
var setVisible = (el, v) => {
  el.style.visibility = v ? "visible" : "hidden";
};
var eventPosition = (e) => {
  var _a;
  if (e.clientX || e.clientX === 0)
    return [e.clientX, e.clientY];
  if ((_a = e.targetTouches) === null || _a === void 0 ? void 0 : _a[0])
    return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];
  return;
};
var isRightButton = (e) => e.buttons === 2 || e.button === 2;
var createEl = (tagName, className) => {
  const el = document.createElement(tagName);
  if (className)
    el.className = className;
  return el;
};
function computeSquareCenter(key, asWhite, bounds) {
  const pos = key2pos(key);
  if (!asWhite) {
    pos[0] = 7 - pos[0];
    pos[1] = 7 - pos[1];
  }
  return [
    bounds.left + bounds.width * pos[0] / 8 + bounds.width / 16,
    bounds.top + bounds.height * (7 - pos[1]) / 8 + bounds.height / 16
  ];
}

export {
  colors,
  files,
  ranks,
  invRanks,
  allKeys,
  pos2key,
  key2pos,
  allPos,
  memo,
  timer,
  opposite,
  distanceSq,
  samePiece,
  posToTranslate,
  translate,
  translateAndScale,
  setVisible,
  eventPosition,
  isRightButton,
  createEl,
  computeSquareCenter
};
//# sourceMappingURL=chunk-S4LCLZCL.js.map
