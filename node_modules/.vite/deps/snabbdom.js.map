{
  "version": 3,
  "sources": ["../../snabbdom/src/htmldomapi.ts", "../../snabbdom/src/vnode.ts", "../../snabbdom/src/is.ts", "../../snabbdom/src/init.ts", "../../snabbdom/src/h.ts", "../../snabbdom/src/thunk.ts", "../../snabbdom/src/helpers/attachto.ts", "../../snabbdom/src/tovnode.ts", "../../snabbdom/src/modules/attributes.ts", "../../snabbdom/src/modules/class.ts", "../../snabbdom/src/modules/dataset.ts", "../../snabbdom/src/modules/eventlisteners.ts", "../../snabbdom/src/modules/props.ts", "../../snabbdom/src/modules/style.ts", "../../snabbdom/src/jsx.ts"],
  "sourcesContent": ["export interface DOMAPI {\n  createElement: (\n    tagName: any,\n    options?: ElementCreationOptions\n  ) => HTMLElement;\n  createElementNS: (\n    namespaceURI: string,\n    qualifiedName: string,\n    options?: ElementCreationOptions\n  ) => Element;\n  /**\n   * @experimental\n   * @todo Make it required when the fragment is considered stable.\n   */\n  createDocumentFragment?: () => DocumentFragment;\n  createTextNode: (text: string) => Text;\n  createComment: (text: string) => Comment;\n  insertBefore: (\n    parentNode: Node,\n    newNode: Node,\n    referenceNode: Node | null\n  ) => void;\n  removeChild: (node: Node, child: Node) => void;\n  appendChild: (node: Node, child: Node) => void;\n  parentNode: (node: Node) => Node | null;\n  nextSibling: (node: Node) => Node | null;\n  tagName: (elm: Element) => string;\n  setTextContent: (node: Node, text: string | null) => void;\n  getTextContent: (node: Node) => string | null;\n  isElement: (node: Node) => node is Element;\n  isText: (node: Node) => node is Text;\n  isComment: (node: Node) => node is Comment;\n  /**\n   * @experimental\n   * @todo Make it required when the fragment is considered stable.\n   */\n  isDocumentFragment?: (node: Node) => node is DocumentFragment;\n}\n\nfunction createElement(\n  tagName: any,\n  options?: ElementCreationOptions\n): HTMLElement {\n  return document.createElement(tagName, options);\n}\n\nfunction createElementNS(\n  namespaceURI: string,\n  qualifiedName: string,\n  options?: ElementCreationOptions\n): Element {\n  return document.createElementNS(namespaceURI, qualifiedName, options);\n}\n\nfunction createDocumentFragment(): DocumentFragment {\n  return document.createDocumentFragment();\n}\n\nfunction createTextNode(text: string): Text {\n  return document.createTextNode(text);\n}\n\nfunction createComment(text: string): Comment {\n  return document.createComment(text);\n}\n\nfunction insertBefore(\n  parentNode: Node,\n  newNode: Node,\n  referenceNode: Node | null\n): void {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild(node: Node, child: Node): void {\n  node.removeChild(child);\n}\n\nfunction appendChild(node: Node, child: Node): void {\n  node.appendChild(child);\n}\n\nfunction parentNode(node: Node): Node | null {\n  return node.parentNode;\n}\n\nfunction nextSibling(node: Node): Node | null {\n  return node.nextSibling;\n}\n\nfunction tagName(elm: Element): string {\n  return elm.tagName;\n}\n\nfunction setTextContent(node: Node, text: string | null): void {\n  node.textContent = text;\n}\n\nfunction getTextContent(node: Node): string | null {\n  return node.textContent;\n}\n\nfunction isElement(node: Node): node is Element {\n  return node.nodeType === 1;\n}\n\nfunction isText(node: Node): node is Text {\n  return node.nodeType === 3;\n}\n\nfunction isComment(node: Node): node is Comment {\n  return node.nodeType === 8;\n}\n\nfunction isDocumentFragment(node: Node): node is DocumentFragment {\n  return node.nodeType === 11;\n}\n\nexport const htmlDomApi: DOMAPI = {\n  createElement,\n  createElementNS,\n  createTextNode,\n  createDocumentFragment,\n  createComment,\n  insertBefore,\n  removeChild,\n  appendChild,\n  parentNode,\n  nextSibling,\n  tagName,\n  setTextContent,\n  getTextContent,\n  isElement,\n  isText,\n  isComment,\n  isDocumentFragment,\n};\n", "import { Hooks } from \"./hooks\";\nimport { AttachData } from \"./helpers/attachto\";\nimport { VNodeStyle } from \"./modules/style\";\nimport { On } from \"./modules/eventlisteners\";\nimport { Attrs } from \"./modules/attributes\";\nimport { Classes } from \"./modules/class\";\nimport { Props } from \"./modules/props\";\nimport { Dataset } from \"./modules/dataset\";\n\nexport type Key = string | number | symbol;\n\nexport interface VNode {\n  sel: string | undefined;\n  data: VNodeData | undefined;\n  children: Array<VNode | string> | undefined;\n  elm: Node | undefined;\n  text: string | undefined;\n  key: Key | undefined;\n}\n\nexport interface VNodeData {\n  props?: Props;\n  attrs?: Attrs;\n  class?: Classes;\n  style?: VNodeStyle;\n  dataset?: Dataset;\n  on?: On;\n  attachData?: AttachData;\n  hook?: Hooks;\n  key?: Key;\n  ns?: string; // for SVGs\n  fn?: () => VNode; // for thunks\n  args?: any[]; // for thunks\n  is?: string; // for custom elements v1\n  [key: string]: any; // for any other 3rd party module\n}\n\nexport function vnode(\n  sel: string | undefined,\n  data: any | undefined,\n  children: Array<VNode | string> | undefined,\n  text: string | undefined,\n  elm: Element | DocumentFragment | Text | undefined\n): VNode {\n  const key = data === undefined ? undefined : data.key;\n  return { sel, data, children, text, elm, key };\n}\n", "export const array = Array.isArray;\nexport function primitive(s: any): s is string | number {\n  return (\n    typeof s === \"string\" ||\n    typeof s === \"number\" ||\n    s instanceof String ||\n    s instanceof Number\n  );\n}\n", "import { Module } from \"./modules/module\";\nimport { vnode, VNode } from \"./vnode\";\nimport * as is from \"./is\";\nimport { htmlDomApi, DOMAPI } from \"./htmldomapi\";\n\ntype NonUndefined<T> = T extends undefined ? never : T;\n\nfunction isUndef(s: any): boolean {\n  return s === undefined;\n}\nfunction isDef<A>(s: A): s is NonUndefined<A> {\n  return s !== undefined;\n}\n\ntype VNodeQueue = VNode[];\n\nconst emptyNode = vnode(\"\", {}, [], undefined, undefined);\n\nfunction sameVnode(vnode1: VNode, vnode2: VNode): boolean {\n  const isSameKey = vnode1.key === vnode2.key;\n  const isSameIs = vnode1.data?.is === vnode2.data?.is;\n  const isSameSel = vnode1.sel === vnode2.sel;\n\n  return isSameSel && isSameKey && isSameIs;\n}\n\n/**\n * @todo Remove this function when the document fragment is considered stable.\n */\nfunction documentFragmentIsNotSupported(): never {\n  throw new Error(\"The document fragment is not supported on this platform.\");\n}\n\nfunction isElement(\n  api: DOMAPI,\n  vnode: Element | DocumentFragment | VNode\n): vnode is Element {\n  return api.isElement(vnode as any);\n}\n\nfunction isDocumentFragment(\n  api: DOMAPI,\n  vnode: DocumentFragment | VNode\n): vnode is DocumentFragment {\n  return api.isDocumentFragment!(vnode as any);\n}\n\ntype KeyToIndexMap = { [key: string]: number };\n\ntype ArraysOf<T> = {\n  [K in keyof T]: Array<T[K]>;\n};\n\ntype ModuleHooks = ArraysOf<Required<Module>>;\n\nfunction createKeyToOldIdx(\n  children: VNode[],\n  beginIdx: number,\n  endIdx: number\n): KeyToIndexMap {\n  const map: KeyToIndexMap = {};\n  for (let i = beginIdx; i <= endIdx; ++i) {\n    const key = children[i]?.key;\n    if (key !== undefined) {\n      map[key as string] = i;\n    }\n  }\n  return map;\n}\n\nconst hooks: Array<keyof Module> = [\n  \"create\",\n  \"update\",\n  \"remove\",\n  \"destroy\",\n  \"pre\",\n  \"post\",\n];\n\n// TODO Should `domApi` be put into this in the next major version bump?\nexport type Options = {\n  experimental?: {\n    fragments?: boolean;\n  };\n};\n\nexport function init(\n  modules: Array<Partial<Module>>,\n  domApi?: DOMAPI,\n  options?: Options\n) {\n  const cbs: ModuleHooks = {\n    create: [],\n    update: [],\n    remove: [],\n    destroy: [],\n    pre: [],\n    post: [],\n  };\n\n  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;\n\n  for (const hook of hooks) {\n    for (const module of modules) {\n      const currentHook = module[hook];\n      if (currentHook !== undefined) {\n        (cbs[hook] as any[]).push(currentHook);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm: Element) {\n    const id = elm.id ? \"#\" + elm.id : \"\";\n\n    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\n    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\n    const classes = elm.getAttribute(\"class\");\n\n    const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\n    return vnode(\n      api.tagName(elm).toLowerCase() + id + c,\n      {},\n      [],\n      undefined,\n      elm\n    );\n  }\n\n  function emptyDocumentFragmentAt(frag: DocumentFragment) {\n    return vnode(undefined, {}, [], undefined, frag);\n  }\n\n  function createRmCb(childElm: Node, listeners: number) {\n    return function rmCb() {\n      if (--listeners === 0) {\n        const parent = api.parentNode(childElm) as Node;\n        api.removeChild(parent, childElm);\n      }\n    };\n  }\n\n  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {\n    let i: any;\n    let data = vnode.data;\n    if (data !== undefined) {\n      const init = data.hook?.init;\n      if (isDef(init)) {\n        init(vnode);\n        data = vnode.data;\n      }\n    }\n    const children = vnode.children;\n    const sel = vnode.sel;\n    if (sel === \"!\") {\n      if (isUndef(vnode.text)) {\n        vnode.text = \"\";\n      }\n      vnode.elm = api.createComment(vnode.text!);\n    } else if (sel !== undefined) {\n      // Parse selector\n      const hashIdx = sel.indexOf(\"#\");\n      const dotIdx = sel.indexOf(\".\", hashIdx);\n      const hash = hashIdx > 0 ? hashIdx : sel.length;\n      const dot = dotIdx > 0 ? dotIdx : sel.length;\n      const tag =\n        hashIdx !== -1 || dotIdx !== -1\n          ? sel.slice(0, Math.min(hash, dot))\n          : sel;\n      const elm = (vnode.elm =\n        isDef(data) && isDef((i = data.ns))\n          ? api.createElementNS(i, tag, data)\n          : api.createElement(tag, data));\n      if (hash < dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n      if (dotIdx > 0)\n        elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\n      if (is.array(children)) {\n        for (i = 0; i < children.length; ++i) {\n          const ch = children[i];\n          if (ch != null) {\n            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));\n          }\n        }\n      } else if (is.primitive(vnode.text)) {\n        api.appendChild(elm, api.createTextNode(vnode.text));\n      }\n      const hook = vnode.data!.hook;\n      if (isDef(hook)) {\n        hook.create?.(emptyNode, vnode);\n        if (hook.insert) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } else if (options?.experimental?.fragments && vnode.children) {\n      const children = vnode.children;\n      vnode.elm = (\n        api.createDocumentFragment ?? documentFragmentIsNotSupported\n      )();\n      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);\n      for (i = 0; i < children.length; ++i) {\n        const ch = children[i];\n        if (ch != null) {\n          api.appendChild(\n            vnode.elm,\n            createElm(ch as VNode, insertedVnodeQueue)\n          );\n        }\n      }\n    } else {\n      vnode.elm = api.createTextNode(vnode.text!);\n    }\n    return vnode.elm;\n  }\n\n  function addVnodes(\n    parentElm: Node,\n    before: Node | null,\n    vnodes: VNode[],\n    startIdx: number,\n    endIdx: number,\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      const ch = vnodes[startIdx];\n      if (ch != null) {\n        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n      }\n    }\n  }\n\n  function invokeDestroyHook(vnode: VNode) {\n    const data = vnode.data;\n    if (data !== undefined) {\n      data?.hook?.destroy?.(vnode);\n      for (let i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);\n      if (vnode.children !== undefined) {\n        for (let j = 0; j < vnode.children.length; ++j) {\n          const child = vnode.children[j];\n          if (child != null && typeof child !== \"string\") {\n            invokeDestroyHook(child);\n          }\n        }\n      }\n    }\n  }\n\n  function removeVnodes(\n    parentElm: Node,\n    vnodes: VNode[],\n    startIdx: number,\n    endIdx: number\n  ): void {\n    for (; startIdx <= endIdx; ++startIdx) {\n      let listeners: number;\n      let rm: () => void;\n      const ch = vnodes[startIdx];\n      if (ch != null) {\n        if (isDef(ch.sel)) {\n          invokeDestroyHook(ch);\n          listeners = cbs.remove.length + 1;\n          rm = createRmCb(ch.elm!, listeners);\n          for (let i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);\n          const removeHook = ch?.data?.hook?.remove;\n          if (isDef(removeHook)) {\n            removeHook(ch, rm);\n          } else {\n            rm();\n          }\n        } else {\n          // Text node\n          api.removeChild(parentElm, ch.elm!);\n        }\n      }\n    }\n  }\n\n  function updateChildren(\n    parentElm: Node,\n    oldCh: VNode[],\n    newCh: VNode[],\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let oldKeyToIdx: KeyToIndexMap | undefined;\n    let idxInOld: number;\n    let elmToMove: VNode;\n    let before: any;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (oldStartVnode == null) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n      } else if (oldEndVnode == null) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (newStartVnode == null) {\n        newStartVnode = newCh[++newStartIdx];\n      } else if (newEndVnode == null) {\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        api.insertBefore(\n          parentElm,\n          oldStartVnode.elm!,\n          api.nextSibling(oldEndVnode.elm!)\n        );\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (oldKeyToIdx === undefined) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n        idxInOld = oldKeyToIdx[newStartVnode.key as string];\n        if (isUndef(idxInOld)) {\n          // New element\n          api.insertBefore(\n            parentElm,\n            createElm(newStartVnode, insertedVnodeQueue),\n            oldStartVnode.elm!\n          );\n        } else {\n          elmToMove = oldCh[idxInOld];\n          if (elmToMove.sel !== newStartVnode.sel) {\n            api.insertBefore(\n              parentElm,\n              createElm(newStartVnode, insertedVnodeQueue),\n              oldStartVnode.elm!\n            );\n          } else {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined as any;\n            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n\n    if (newStartIdx <= newEndIdx) {\n      before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(\n        parentElm,\n        before,\n        newCh,\n        newStartIdx,\n        newEndIdx,\n        insertedVnodeQueue\n      );\n    }\n    if (oldStartIdx <= oldEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode(\n    oldVnode: VNode,\n    vnode: VNode,\n    insertedVnodeQueue: VNodeQueue\n  ) {\n    const hook = vnode.data?.hook;\n    hook?.prepatch?.(oldVnode, vnode);\n    const elm = (vnode.elm = oldVnode.elm)!;\n    const oldCh = oldVnode.children as VNode[];\n    const ch = vnode.children as VNode[];\n    if (oldVnode === vnode) return;\n    if (vnode.data !== undefined) {\n      for (let i = 0; i < cbs.update.length; ++i)\n        cbs.update[i](oldVnode, vnode);\n      vnode.data.hook?.update?.(oldVnode, vnode);\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) api.setTextContent(elm, \"\");\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        api.setTextContent(elm, \"\");\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      }\n      api.setTextContent(elm, vnode.text!);\n    }\n    hook?.postpatch?.(oldVnode, vnode);\n  }\n\n  return function patch(\n    oldVnode: VNode | Element | DocumentFragment,\n    vnode: VNode\n  ): VNode {\n    let i: number, elm: Node, parent: Node;\n    const insertedVnodeQueue: VNodeQueue = [];\n    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();\n\n    if (isElement(api, oldVnode)) {\n      oldVnode = emptyNodeAt(oldVnode);\n    } else if (isDocumentFragment(api, oldVnode)) {\n      oldVnode = emptyDocumentFragmentAt(oldVnode);\n    }\n\n    if (sameVnode(oldVnode, vnode)) {\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\n    } else {\n      elm = oldVnode.elm!;\n      parent = api.parentNode(elm) as Node;\n\n      createElm(vnode, insertedVnodeQueue);\n\n      if (parent !== null) {\n        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));\n        removeVnodes(parent, [oldVnode], 0, 0);\n      }\n    }\n\n    for (i = 0; i < insertedVnodeQueue.length; ++i) {\n      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);\n    }\n    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();\n    return vnode;\n  };\n}\n", "import { vnode, VNode, VNodeData } from \"./vnode\";\nimport * as is from \"./is\";\n\nexport type VNodes = VNode[];\nexport type VNodeChildElement =\n  | VNode\n  | string\n  | number\n  | String\n  | Number\n  | undefined\n  | null;\nexport type ArrayOrElement<T> = T | T[];\nexport type VNodeChildren = ArrayOrElement<VNodeChildElement>;\n\nexport function addNS(\n  data: any,\n  children: Array<VNode | string> | undefined,\n  sel: string | undefined\n): void {\n  data.ns = \"http://www.w3.org/2000/svg\";\n  if (sel !== \"foreignObject\" && children !== undefined) {\n    for (let i = 0; i < children.length; ++i) {\n      const child = children[i];\n      if (typeof child === \"string\") continue;\n      const childData = child.data;\n      if (childData !== undefined) {\n        addNS(childData, child.children as VNodes, child.sel);\n      }\n    }\n  }\n}\n\nexport function h(sel: string): VNode;\nexport function h(sel: string, data: VNodeData | null): VNode;\nexport function h(sel: string, children: VNodeChildren): VNode;\nexport function h(\n  sel: string,\n  data: VNodeData | null,\n  children: VNodeChildren\n): VNode;\nexport function h(sel: any, b?: any, c?: any): VNode {\n  let data: VNodeData = {};\n  let children: any;\n  let text: any;\n  let i: number;\n  if (c !== undefined) {\n    if (b !== null) {\n      data = b;\n    }\n    if (is.array(c)) {\n      children = c;\n    } else if (is.primitive(c)) {\n      text = c.toString();\n    } else if (c && c.sel) {\n      children = [c];\n    }\n  } else if (b !== undefined && b !== null) {\n    if (is.array(b)) {\n      children = b;\n    } else if (is.primitive(b)) {\n      text = b.toString();\n    } else if (b && b.sel) {\n      children = [b];\n    } else {\n      data = b;\n    }\n  }\n  if (children !== undefined) {\n    for (i = 0; i < children.length; ++i) {\n      if (is.primitive(children[i]))\n        children[i] = vnode(\n          undefined,\n          undefined,\n          undefined,\n          children[i],\n          undefined\n        );\n    }\n  }\n  if (\n    sel[0] === \"s\" &&\n    sel[1] === \"v\" &&\n    sel[2] === \"g\" &&\n    (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")\n  ) {\n    addNS(data, children, sel);\n  }\n  return vnode(sel, data, children, text, undefined);\n}\n\n/**\n * @experimental\n */\nexport function fragment(children: VNodeChildren): VNode {\n  let c: any;\n  let text: any;\n\n  if (is.array(children)) {\n    c = children;\n  } else if (is.primitive(c)) {\n    text = children;\n  } else if (c && c.sel) {\n    c = [children];\n  }\n\n  if (c !== undefined) {\n    for (let i = 0; i < c.length; ++i) {\n      if (is.primitive(c[i]))\n        c[i] = vnode(undefined, undefined, undefined, c[i], undefined);\n    }\n  }\n\n  return vnode(undefined, {}, c, text, undefined);\n}\n", "import { VNode, VNodeData } from \"./vnode\";\nimport { h, addNS } from \"./h\";\n\nexport interface ThunkData extends VNodeData {\n  fn: () => VNode;\n  args: any[];\n}\n\nexport interface Thunk extends VNode {\n  data: ThunkData;\n}\n\nexport interface ThunkFn {\n  (sel: string, fn: (...args: any[]) => any, args: any[]): Thunk;\n  (sel: string, key: any, fn: (...args: any[]) => any, args: any[]): Thunk;\n}\n\nfunction copyToThunk(vnode: VNode, thunk: VNode): void {\n  const ns = thunk.data?.ns;\n  (vnode.data as VNodeData).fn = (thunk.data as VNodeData).fn;\n  (vnode.data as VNodeData).args = (thunk.data as VNodeData).args;\n  thunk.data = vnode.data;\n  thunk.children = vnode.children;\n  thunk.text = vnode.text;\n  thunk.elm = vnode.elm;\n  if (ns) addNS(thunk.data, thunk.children, thunk.sel);\n}\n\nfunction init(thunk: VNode): void {\n  const cur = thunk.data as VNodeData;\n  const vnode = (cur.fn as any)(...cur.args!);\n  copyToThunk(vnode, thunk);\n}\n\nfunction prepatch(oldVnode: VNode, thunk: VNode): void {\n  let i: number;\n  const old = oldVnode.data as VNodeData;\n  const cur = thunk.data as VNodeData;\n  const oldArgs = old.args;\n  const args = cur.args;\n  if (old.fn !== cur.fn || (oldArgs as any).length !== (args as any).length) {\n    copyToThunk((cur.fn as any)(...args!), thunk);\n    return;\n  }\n  for (i = 0; i < (args as any).length; ++i) {\n    if ((oldArgs as any)[i] !== (args as any)[i]) {\n      copyToThunk((cur.fn as any)(...args!), thunk);\n      return;\n    }\n  }\n  copyToThunk(oldVnode, thunk);\n}\n\nexport const thunk = function thunk(\n  sel: string,\n  key?: any,\n  fn?: any,\n  args?: any\n): VNode {\n  if (args === undefined) {\n    args = fn;\n    fn = key;\n    key = undefined;\n  }\n  return h(sel, {\n    key: key,\n    hook: { init, prepatch },\n    fn: fn,\n    args: args,\n  });\n} as ThunkFn;\n", "import { VNode, VNodeData } from \"../vnode\";\n\nexport interface AttachData {\n  [key: string]: any;\n  [i: number]: any;\n  placeholder?: any;\n  real?: Node;\n}\n\ninterface VNodeDataWithAttach extends VNodeData {\n  attachData: AttachData;\n}\n\ninterface VNodeWithAttachData extends VNode {\n  data: VNodeDataWithAttach;\n}\n\nfunction pre(vnode: VNodeWithAttachData, newVnode: VNodeWithAttachData): void {\n  const attachData = vnode.data.attachData;\n  // Copy created placeholder and real element from old vnode\n  newVnode.data.attachData.placeholder = attachData.placeholder;\n  newVnode.data.attachData.real = attachData.real;\n  // Mount real element in vnode so the patch process operates on it\n  vnode.elm = vnode.data.attachData.real;\n}\n\nfunction post(_: any, vnode: VNodeWithAttachData): void {\n  // Mount dummy placeholder in vnode so potential reorders use it\n  vnode.elm = vnode.data.attachData.placeholder;\n}\n\nfunction destroy(vnode: VNodeWithAttachData): void {\n  // Remove placeholder\n  if (vnode.elm !== undefined) {\n    (vnode.elm.parentNode as HTMLElement).removeChild(vnode.elm);\n  }\n  // Remove real element from where it was inserted\n  vnode.elm = vnode.data.attachData.real;\n}\n\nfunction create(_: any, vnode: VNodeWithAttachData): void {\n  const real = vnode.elm;\n  const attachData = vnode.data.attachData;\n  const placeholder = document.createElement(\"span\");\n  // Replace actual element with dummy placeholder\n  // Snabbdom will then insert placeholder instead\n  vnode.elm = placeholder;\n  attachData.target.appendChild(real);\n  attachData.real = real;\n  attachData.placeholder = placeholder;\n}\n\nexport function attachTo(target: Element, vnode: VNode): VNode {\n  if (vnode.data === undefined) vnode.data = {};\n  if (vnode.data.hook === undefined) vnode.data.hook = {};\n  const data = vnode.data;\n  const hook = vnode.data.hook;\n  data.attachData = { target: target, placeholder: undefined, real: undefined };\n  hook.create = create;\n  hook.prepatch = pre;\n  hook.postpatch = post;\n  hook.destroy = destroy;\n  return vnode;\n}\n", "import { addNS } from \"./h\";\nimport { vnode, VNode } from \"./vnode\";\nimport { htmlDomApi, DOMAPI } from \"./htmldomapi\";\n\nexport function toVNode(node: Node, domApi?: DOMAPI): VNode {\n  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;\n  let text: string;\n  if (api.isElement(node)) {\n    const id = node.id ? \"#\" + node.id : \"\";\n    const cn = node.getAttribute(\"class\");\n    const c = cn ? \".\" + cn.split(\" \").join(\".\") : \"\";\n    const sel = api.tagName(node).toLowerCase() + id + c;\n    const attrs: any = {};\n    const datasets: Record<string, string> = {};\n    const data: Record<string, any> = {};\n\n    const children: VNode[] = [];\n    let name: string;\n    let i: number, n: number;\n    const elmAttrs = node.attributes;\n    const elmChildren = node.childNodes;\n    for (i = 0, n = elmAttrs.length; i < n; i++) {\n      name = elmAttrs[i].nodeName;\n      if (\n        name[0] === \"d\" &&\n        name[1] === \"a\" &&\n        name[2] === \"t\" &&\n        name[3] === \"a\" &&\n        name[4] === \"-\"\n      ) {\n        datasets[name.slice(5)] = elmAttrs[i].nodeValue || \"\";\n      } else if (name !== \"id\" && name !== \"class\") {\n        attrs[name] = elmAttrs[i].nodeValue;\n      }\n    }\n    for (i = 0, n = elmChildren.length; i < n; i++) {\n      children.push(toVNode(elmChildren[i], domApi));\n    }\n\n    if (Object.keys(attrs).length > 0) data.attrs = attrs;\n    if (Object.keys(datasets).length > 0) data.datasets = datasets;\n\n    if (\n      sel[0] === \"s\" &&\n      sel[1] === \"v\" &&\n      sel[2] === \"g\" &&\n      (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")\n    ) {\n      addNS(data, children, sel);\n    }\n    return vnode(sel, data, children, undefined, node);\n  } else if (api.isText(node)) {\n    text = api.getTextContent(node) as string;\n    return vnode(undefined, undefined, undefined, text, node);\n  } else if (api.isComment(node)) {\n    text = api.getTextContent(node) as string;\n    return vnode(\"!\", {}, [], text, node as any);\n  } else {\n    return vnode(\"\", {}, [], undefined, node as any);\n  }\n}\n", "import { VNode, VNodeData } from \"../vnode\";\nimport { Module } from \"./module\";\n\nexport type Attrs = Record<string, string | number | boolean>;\n\nconst xlinkNS = \"http://www.w3.org/1999/xlink\";\nconst xmlNS = \"http://www.w3.org/XML/1998/namespace\";\nconst colonChar = 58;\nconst xChar = 120;\n\nfunction updateAttrs(oldVnode: VNode, vnode: VNode): void {\n  let key: string;\n  const elm: Element = vnode.elm as Element;\n  let oldAttrs = (oldVnode.data as VNodeData).attrs;\n  let attrs = (vnode.data as VNodeData).attrs;\n\n  if (!oldAttrs && !attrs) return;\n  if (oldAttrs === attrs) return;\n  oldAttrs = oldAttrs || {};\n  attrs = attrs || {};\n\n  // update modified attributes, add new attributes\n  for (key in attrs) {\n    const cur = attrs[key];\n    const old = oldAttrs[key];\n    if (old !== cur) {\n      if (cur === true) {\n        elm.setAttribute(key, \"\");\n      } else if (cur === false) {\n        elm.removeAttribute(key);\n      } else {\n        if (key.charCodeAt(0) !== xChar) {\n          elm.setAttribute(key, cur as any);\n        } else if (key.charCodeAt(3) === colonChar) {\n          // Assume xml namespace\n          elm.setAttributeNS(xmlNS, key, cur as any);\n        } else if (key.charCodeAt(5) === colonChar) {\n          // Assume xlink namespace\n          elm.setAttributeNS(xlinkNS, key, cur as any);\n        } else {\n          elm.setAttribute(key, cur as any);\n        }\n      }\n    }\n  }\n  // remove removed attributes\n  // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)\n  // the other option is to remove all attributes with value == undefined\n  for (key in oldAttrs) {\n    if (!(key in attrs)) {\n      elm.removeAttribute(key);\n    }\n  }\n}\n\nexport const attributesModule: Module = {\n  create: updateAttrs,\n  update: updateAttrs,\n};\n", "import { VNode, VNodeData } from \"../vnode\";\nimport { Module } from \"./module\";\n\nexport type Classes = Record<string, boolean>;\n\nfunction updateClass(oldVnode: VNode, vnode: VNode): void {\n  let cur: any;\n  let name: string;\n  const elm: Element = vnode.elm as Element;\n  let oldClass = (oldVnode.data as VNodeData).class;\n  let klass = (vnode.data as VNodeData).class;\n\n  if (!oldClass && !klass) return;\n  if (oldClass === klass) return;\n  oldClass = oldClass || {};\n  klass = klass || {};\n\n  for (name in oldClass) {\n    if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) {\n      // was `true` and now not provided\n      elm.classList.remove(name);\n    }\n  }\n  for (name in klass) {\n    cur = klass[name];\n    if (cur !== oldClass[name]) {\n      (elm.classList as any)[cur ? \"add\" : \"remove\"](name);\n    }\n  }\n}\n\nexport const classModule: Module = { create: updateClass, update: updateClass };\n", "import { VNode, VNodeData } from \"../vnode\";\nimport { Module } from \"./module\";\n\nexport type Dataset = Record<string, string>;\n\nconst CAPS_REGEX = /[A-Z]/g;\n\nfunction updateDataset(oldVnode: VNode, vnode: VNode): void {\n  const elm: HTMLElement = vnode.elm as HTMLElement;\n  let oldDataset = (oldVnode.data as VNodeData).dataset;\n  let dataset = (vnode.data as VNodeData).dataset;\n  let key: string;\n\n  if (!oldDataset && !dataset) return;\n  if (oldDataset === dataset) return;\n  oldDataset = oldDataset || {};\n  dataset = dataset || {};\n  const d = elm.dataset;\n\n  for (key in oldDataset) {\n    if (!dataset[key]) {\n      if (d) {\n        if (key in d) {\n          delete d[key];\n        }\n      } else {\n        elm.removeAttribute(\n          \"data-\" + key.replace(CAPS_REGEX, \"-$&\").toLowerCase()\n        );\n      }\n    }\n  }\n  for (key in dataset) {\n    if (oldDataset[key] !== dataset[key]) {\n      if (d) {\n        d[key] = dataset[key];\n      } else {\n        elm.setAttribute(\n          \"data-\" + key.replace(CAPS_REGEX, \"-$&\").toLowerCase(),\n          dataset[key]\n        );\n      }\n    }\n  }\n}\n\nexport const datasetModule: Module = {\n  create: updateDataset,\n  update: updateDataset,\n};\n", "import { VNode, VNodeData } from \"../vnode\";\nimport { Module } from \"./module\";\n\ntype Listener<T> = (this: VNode, ev: T, vnode: VNode) => void;\n\nexport type On = {\n  [N in keyof HTMLElementEventMap]?:\n    | Listener<HTMLElementEventMap[N]>\n    | Array<Listener<HTMLElementEventMap[N]>>;\n} & {\n  [event: string]: Listener<any> | Array<Listener<any>>;\n};\n\ntype SomeListener<N extends keyof HTMLElementEventMap> =\n  | Listener<HTMLElementEventMap[N]>\n  | Listener<any>;\n\nfunction invokeHandler<N extends keyof HTMLElementEventMap>(\n  handler: SomeListener<N> | Array<SomeListener<N>>,\n  vnode: VNode,\n  event?: Event\n): void {\n  if (typeof handler === \"function\") {\n    // call function handler\n    handler.call(vnode, event, vnode);\n  } else if (typeof handler === \"object\") {\n    // call multiple handlers\n    for (let i = 0; i < handler.length; i++) {\n      invokeHandler(handler[i], vnode, event);\n    }\n  }\n}\n\nfunction handleEvent(event: Event, vnode: VNode) {\n  const name = event.type;\n  const on = (vnode.data as VNodeData).on;\n\n  // call event handler(s) if exists\n  if (on && on[name]) {\n    invokeHandler(on[name], vnode, event);\n  }\n}\n\nfunction createListener() {\n  return function handler(event: Event) {\n    handleEvent(event, (handler as any).vnode);\n  };\n}\n\nfunction updateEventListeners(oldVnode: VNode, vnode?: VNode): void {\n  const oldOn = (oldVnode.data as VNodeData).on;\n  const oldListener = (oldVnode as any).listener;\n  const oldElm: Element = oldVnode.elm as Element;\n  const on = vnode && (vnode.data as VNodeData).on;\n  const elm: Element = (vnode && vnode.elm) as Element;\n  let name: string;\n\n  // optimization for reused immutable handlers\n  if (oldOn === on) {\n    return;\n  }\n\n  // remove existing listeners which no longer used\n  if (oldOn && oldListener) {\n    // if element changed or deleted we remove all existing listeners unconditionally\n    if (!on) {\n      for (name in oldOn) {\n        // remove listener if element was changed or existing listeners removed\n        oldElm.removeEventListener(name, oldListener, false);\n      }\n    } else {\n      for (name in oldOn) {\n        // remove listener if existing listener removed\n        if (!on[name]) {\n          oldElm.removeEventListener(name, oldListener, false);\n        }\n      }\n    }\n  }\n\n  // add new listeners which has not already attached\n  if (on) {\n    // reuse existing listener or create new\n    const listener = ((vnode as any).listener =\n      (oldVnode as any).listener || createListener());\n    // update vnode for listener\n    listener.vnode = vnode;\n\n    // if element changed or added we add all needed listeners unconditionally\n    if (!oldOn) {\n      for (name in on) {\n        // add listener if element was changed or new listeners added\n        elm.addEventListener(name, listener, false);\n      }\n    } else {\n      for (name in on) {\n        // add listener if new listener added\n        if (!oldOn[name]) {\n          elm.addEventListener(name, listener, false);\n        }\n      }\n    }\n  }\n}\n\nexport const eventListenersModule: Module = {\n  create: updateEventListeners,\n  update: updateEventListeners,\n  destroy: updateEventListeners,\n};\n", "import { VNode, VNodeData } from \"../vnode\";\nimport { Module } from \"./module\";\n\nexport type Props = Record<string, any>;\n\nfunction updateProps(oldVnode: VNode, vnode: VNode): void {\n  let key: string;\n  let cur: any;\n  let old: any;\n  const elm = vnode.elm;\n  let oldProps = (oldVnode.data as VNodeData).props;\n  let props = (vnode.data as VNodeData).props;\n\n  if (!oldProps && !props) return;\n  if (oldProps === props) return;\n  oldProps = oldProps || {};\n  props = props || {};\n\n  for (key in props) {\n    cur = props[key];\n    old = oldProps[key];\n    if (old !== cur && (key !== \"value\" || (elm as any)[key] !== cur)) {\n      (elm as any)[key] = cur;\n    }\n  }\n}\n\nexport const propsModule: Module = { create: updateProps, update: updateProps };\n", "import { VNode, VNodeData } from \"../vnode\";\nimport { Module } from \"./module\";\n\nexport type VNodeStyle = Record<string, string> & {\n  delayed?: Record<string, string>;\n  remove?: Record<string, string>;\n};\n\n// Bindig `requestAnimationFrame` like this fixes a bug in IE/Edge. See #360 and #409.\nconst raf =\n  (typeof window !== \"undefined\" &&\n    window.requestAnimationFrame.bind(window)) ||\n  setTimeout;\nconst nextFrame = function (fn: any) {\n  raf(function () {\n    raf(fn);\n  });\n};\nlet reflowForced = false;\n\nfunction setNextFrame(obj: any, prop: string, val: any): void {\n  nextFrame(function () {\n    obj[prop] = val;\n  });\n}\n\nfunction updateStyle(oldVnode: VNode, vnode: VNode): void {\n  let cur: any;\n  let name: string;\n  const elm = vnode.elm;\n  let oldStyle = (oldVnode.data as VNodeData).style;\n  let style = (vnode.data as VNodeData).style;\n\n  if (!oldStyle && !style) return;\n  if (oldStyle === style) return;\n  oldStyle = oldStyle || {};\n  style = style || {};\n  const oldHasDel = \"delayed\" in oldStyle;\n\n  for (name in oldStyle) {\n    if (!style[name]) {\n      if (name[0] === \"-\" && name[1] === \"-\") {\n        (elm as any).style.removeProperty(name);\n      } else {\n        (elm as any).style[name] = \"\";\n      }\n    }\n  }\n  for (name in style) {\n    cur = style[name];\n    if (name === \"delayed\" && style.delayed) {\n      for (const name2 in style.delayed) {\n        cur = style.delayed[name2];\n        if (!oldHasDel || cur !== (oldStyle.delayed as any)[name2]) {\n          setNextFrame((elm as any).style, name2, cur);\n        }\n      }\n    } else if (name !== \"remove\" && cur !== oldStyle[name]) {\n      if (name[0] === \"-\" && name[1] === \"-\") {\n        (elm as any).style.setProperty(name, cur);\n      } else {\n        (elm as any).style[name] = cur;\n      }\n    }\n  }\n}\n\nfunction applyDestroyStyle(vnode: VNode): void {\n  let style: any;\n  let name: string;\n  const elm = vnode.elm;\n  const s = (vnode.data as VNodeData).style;\n  if (!s || !(style = s.destroy)) return;\n  for (name in style) {\n    (elm as any).style[name] = style[name];\n  }\n}\n\nfunction applyRemoveStyle(vnode: VNode, rm: () => void): void {\n  const s = (vnode.data as VNodeData).style;\n  if (!s || !s.remove) {\n    rm();\n    return;\n  }\n  if (!reflowForced) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n    (vnode.elm as any).offsetLeft;\n    reflowForced = true;\n  }\n  let name: string;\n  const elm = vnode.elm;\n  let i = 0;\n  const style = s.remove;\n  let amount = 0;\n  const applied: string[] = [];\n  for (name in style) {\n    applied.push(name);\n    (elm as any).style[name] = style[name];\n  }\n  const compStyle = getComputedStyle(elm as Element);\n  const props = (compStyle as any)[\"transition-property\"].split(\", \");\n  for (; i < props.length; ++i) {\n    if (applied.indexOf(props[i]) !== -1) amount++;\n  }\n  (elm as Element).addEventListener(\n    \"transitionend\",\n    function (ev: TransitionEvent) {\n      if (ev.target === elm) --amount;\n      if (amount === 0) rm();\n    }\n  );\n}\n\nfunction forceReflow() {\n  reflowForced = false;\n}\n\nexport const styleModule: Module = {\n  pre: forceReflow,\n  create: updateStyle,\n  update: updateStyle,\n  destroy: applyDestroyStyle,\n  remove: applyRemoveStyle,\n};\n", "/* eslint-disable @typescript-eslint/no-namespace, import/export */\nimport { Key, vnode, VNode, VNodeData } from \"./vnode\";\nimport { h, ArrayOrElement } from \"./h\";\n\n// See https://www.typescriptlang.org/docs/handbook/jsx.html#type-checking\nnamespace JSXInternal {\n  export type Element = VNode;\n  export interface IntrinsicElements {\n    [elemName: string]: VNodeData;\n  }\n}\n\n// for conditional rendering we support boolean child element e.g cond && <tag />\nexport type JsxVNodeChild =\n  | VNode\n  | string\n  | number\n  | boolean\n  | undefined\n  | null;\nexport type JsxVNodeChildren = ArrayOrElement<JsxVNodeChild>;\n\nexport type FunctionComponent = (\n  props: { [prop: string]: any } | null,\n  children?: VNode[]\n) => VNode;\n\nexport function Fragment(\n  data: { key?: Key } | null,\n  ...children: JsxVNodeChildren[]\n): VNode {\n  const flatChildren = flattenAndFilter(children, []);\n\n  if (\n    flatChildren.length === 1 &&\n    !flatChildren[0].sel &&\n    flatChildren[0].text\n  ) {\n    // only child is a simple text node, pass as text for a simpler vtree\n    return vnode(\n      undefined,\n      undefined,\n      undefined,\n      flatChildren[0].text,\n      undefined\n    );\n  } else {\n    return vnode(undefined, data ?? {}, flatChildren, undefined, undefined);\n  }\n}\n\nfunction flattenAndFilter(\n  children: JsxVNodeChildren[],\n  flattened: VNode[]\n): VNode[] {\n  for (const child of children) {\n    // filter out falsey children, except 0 since zero can be a valid value e.g inside a chart\n    if (\n      child !== undefined &&\n      child !== null &&\n      child !== false &&\n      child !== \"\"\n    ) {\n      if (Array.isArray(child)) {\n        flattenAndFilter(child, flattened);\n      } else if (\n        typeof child === \"string\" ||\n        typeof child === \"number\" ||\n        typeof child === \"boolean\"\n      ) {\n        flattened.push(\n          vnode(undefined, undefined, undefined, String(child), undefined)\n        );\n      } else {\n        flattened.push(child);\n      }\n    }\n  }\n  return flattened;\n}\n\n/**\n * jsx/tsx compatible factory function\n * see: https://www.typescriptlang.org/docs/handbook/jsx.html#factory-functions\n */\nexport function jsx(\n  tag: string | FunctionComponent,\n  data: VNodeData | null,\n  ...children: JsxVNodeChildren[]\n): VNode {\n  const flatChildren = flattenAndFilter(children, []);\n  if (typeof tag === \"function\") {\n    // tag is a function component\n    return tag(data, flatChildren);\n  } else {\n    if (\n      flatChildren.length === 1 &&\n      !flatChildren[0].sel &&\n      flatChildren[0].text\n    ) {\n      // only child is a simple text node, pass as text for a simpler vtree\n      return h(tag, data, flatChildren[0].text);\n    } else {\n      return h(tag, data, flatChildren);\n    }\n  }\n}\n\nexport namespace jsx {\n  export import JSX = JSXInternal; // eslint-disable-line @typescript-eslint/no-unused-vars\n}\n"],
  "mappings": "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",
  "names": ["tagName", "parentNode", "isElement", "vnode", "isDocumentFragment", "init", "children", "vnode", "thunk", "init", "vnode", "vnode", "vnode", "vnode", "vnode", "vnode", "vnode", "jsx"]
}
