"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubstrateApp = void 0;
const common_1 = require("./common");
class SubstrateApp {
    constructor(transport, cla, slip0044) {
        if (transport == null) {
            throw new Error("Transport has not been defined");
        }
        this.transport = transport;
        this.cla = cla;
        this.slip0044 = slip0044;
    }
    static serializePath(slip0044, account, change, addressIndex) {
        if (!Number.isInteger(account))
            throw new Error("Input must be an integer");
        if (!Number.isInteger(change))
            throw new Error("Input must be an integer");
        if (!Number.isInteger(addressIndex))
            throw new Error("Input must be an integer");
        const buf = Buffer.alloc(20);
        buf.writeUInt32LE(0x8000002c, 0);
        buf.writeUInt32LE(slip0044, 4);
        buf.writeUInt32LE(account, 8);
        buf.writeUInt32LE(change, 12);
        buf.writeUInt32LE(addressIndex, 16);
        return buf;
    }
    static GetChunks(message) {
        const chunks = [];
        const buffer = Buffer.from(message);
        for (let i = 0; i < buffer.length; i += common_1.CHUNK_SIZE) {
            let end = i + common_1.CHUNK_SIZE;
            if (i > buffer.length) {
                end = buffer.length;
            }
            chunks.push(buffer.subarray(i, end));
        }
        return chunks;
    }
    static signGetChunks(slip0044, account, change, addressIndex, message) {
        const chunks = [];
        const bip44Path = SubstrateApp.serializePath(slip0044, account, change, addressIndex);
        chunks.push(bip44Path);
        chunks.push(...SubstrateApp.GetChunks(message));
        return chunks;
    }
    async getVersion() {
        try {
            return await (0, common_1.getVersion)(this.transport, this.cla);
        }
        catch (e) {
            return (0, common_1.processErrorResponse)(e);
        }
    }
    async appInfo() {
        return await this.transport.send(0xb0, 0x01, 0, 0).then((response) => {
            const errorCodeData = response.subarray(-2);
            const returnCode = errorCodeData[0] * 256 + errorCodeData[1];
            let appName = "";
            let appVersion = "";
            let flagLen = 0;
            let flagsValue = 0;
            if (response[0] !== 1) {
                // Ledger responds with format ID 1. There is no spec for any format != 1
                return {
                    return_code: 0x9001,
                    error_message: "response format ID not recognized",
                };
            }
            else {
                const appNameLen = response[1];
                appName = response.subarray(2, 2 + appNameLen).toString("ascii");
                let idx = 2 + appNameLen;
                const appVersionLen = response[idx];
                idx += 1;
                appVersion = response.subarray(idx, idx + appVersionLen).toString("ascii");
                idx += appVersionLen;
                const appFlagsLen = response[idx];
                idx += 1;
                flagLen = appFlagsLen;
                flagsValue = response[idx];
            }
            return {
                return_code: returnCode,
                error_message: (0, common_1.errorCodeToString)(returnCode),
                // //
                appName: appName === "" || "err",
                appVersion: appVersion === "" || "err",
                flagLen,
                flagsValue,
                // eslint-disable-next-line no-bitwise
                flag_recovery: (flagsValue & 1) !== 0,
                // eslint-disable-next-line no-bitwise
                flag_signed_mcu_code: (flagsValue & 2) !== 0,
                // eslint-disable-next-line no-bitwise
                flag_onboarded: (flagsValue & 4) !== 0,
                // eslint-disable-next-line no-bitwise
                flag_pin_validated: (flagsValue & 128) !== 0,
            };
        }, common_1.processErrorResponse);
    }
    async getAddress(account, change, addressIndex, requireConfirmation = false, scheme = 0 /* SCHEME.ED25519 */) {
        const bip44Path = SubstrateApp.serializePath(this.slip0044, account, change, addressIndex);
        let p1 = 0;
        if (requireConfirmation)
            p1 = 1;
        let p2 = 0;
        if (!isNaN(scheme))
            p2 = scheme;
        return await this.transport.send(this.cla, 1 /* INS.GET_ADDR */, p1, p2, bip44Path).then((response) => {
            const errorCodeData = response.subarray(-2);
            const errorCode = errorCodeData[0] * 256 + errorCodeData[1];
            return {
                pubKey: response.subarray(0, 32).toString("hex"),
                address: response.subarray(32, response.length - 2).toString("ascii"),
                return_code: errorCode,
                error_message: (0, common_1.errorCodeToString)(errorCode),
            };
        }, common_1.processErrorResponse);
    }
    async signSendChunk(chunkIdx, chunkNum, chunk, scheme = 0 /* SCHEME.ED25519 */, ins = 2 /* INS.SIGN */) {
        let payloadType = 1 /* PAYLOAD_TYPE.ADD */;
        if (chunkIdx === 1) {
            payloadType = 0 /* PAYLOAD_TYPE.INIT */;
        }
        if (chunkIdx === chunkNum) {
            payloadType = 2 /* PAYLOAD_TYPE.LAST */;
        }
        let p2 = 0;
        if (!isNaN(scheme))
            p2 = scheme;
        return await this.transport
            .send(this.cla, ins, payloadType, p2, chunk, [36864 /* ERROR_CODE.NoError */, 0x6984, 0x6a80])
            .then((response) => {
            const errorCodeData = response.subarray(-2);
            const returnCode = errorCodeData[0] * 256 + errorCodeData[1];
            let errorMessage = (0, common_1.errorCodeToString)(returnCode);
            let signature = null;
            if (returnCode === 0x6a80 || returnCode === 0x6984) {
                errorMessage = response.subarray(0, response.length - 2).toString("ascii");
            }
            else if (response.length > 2) {
                signature = response.subarray(0, response.length - 2);
            }
            return {
                signature,
                return_code: returnCode,
                error_message: errorMessage,
            };
        }, common_1.processErrorResponse);
    }
    async signImpl(account, change, addressIndex, message, ins, scheme = 0 /* SCHEME.ED25519 */) {
        const chunks = SubstrateApp.signGetChunks(this.slip0044, account, change, addressIndex, message);
        return await this.signSendChunk(1, chunks.length, chunks[0], scheme, ins).then(async () => {
            let result;
            for (let i = 1; i < chunks.length; i += 1) {
                result = await this.signSendChunk(1 + i, chunks.length, chunks[i], scheme, ins);
                if (result.return_code !== 36864 /* ERROR_CODE.NoError */) {
                    break;
                }
            }
            return {
                return_code: result.return_code,
                error_message: result.error_message,
                signature: result.signature,
            };
        }, common_1.processErrorResponse);
    }
    async sign(account, change, addressIndex, message, scheme = 0 /* SCHEME.ED25519 */) {
        return await this.signImpl(account, change, addressIndex, message, 2 /* INS.SIGN */, scheme);
    }
    async signRaw(account, change, addressIndex, message, scheme = 0 /* SCHEME.ED25519 */) {
        return await this.signImpl(account, change, addressIndex, message, 3 /* INS.SIGN_RAW */, scheme);
    }
    /// Allow list related commands. They are NOT available on all apps
    async getAllowlistPubKey() {
        return await this.transport.send(this.cla, 144 /* INS.ALLOWLIST_GET_PUBKEY */, 0, 0).then((response) => {
            const errorCodeData = response.subarray(-2);
            const returnCode = errorCodeData[0] * 256 + errorCodeData[1];
            console.log(response);
            const pubkey = response.subarray(0, 32);
            // 32 bytes + 2 error code
            if (response.length !== 34) {
                return {
                    return_code: 0x6984,
                    error_message: (0, common_1.errorCodeToString)(0x6984),
                };
            }
            return {
                return_code: returnCode,
                error_message: (0, common_1.errorCodeToString)(returnCode),
                pubkey,
            };
        }, common_1.processErrorResponse);
    }
    async setAllowlistPubKey(pk) {
        return await this.transport.send(this.cla, 145 /* INS.ALLOWLIST_SET_PUBKEY */, 0, 0, pk).then((response) => {
            const errorCodeData = response.subarray(-2);
            const returnCode = errorCodeData[0] * 256 + errorCodeData[1];
            return {
                return_code: returnCode,
                error_message: (0, common_1.errorCodeToString)(returnCode),
            };
        }, common_1.processErrorResponse);
    }
    async getAllowlistHash() {
        return await this.transport.send(this.cla, 146 /* INS.ALLOWLIST_GET_HASH */, 0, 0).then((response) => {
            const errorCodeData = response.subarray(-2);
            const returnCode = errorCodeData[0] * 256 + errorCodeData[1];
            console.log(response);
            const hash = response.subarray(0, 32);
            // 32 bytes + 2 error code
            if (response.length !== 34) {
                return {
                    return_code: 0x6984,
                    error_message: (0, common_1.errorCodeToString)(0x6984),
                };
            }
            return {
                return_code: returnCode,
                error_message: (0, common_1.errorCodeToString)(returnCode),
                hash,
            };
        }, common_1.processErrorResponse);
    }
    async uploadSendChunk(chunkIdx, chunkNum, chunk) {
        let payloadType = 1 /* PAYLOAD_TYPE.ADD */;
        if (chunkIdx === 1) {
            payloadType = 0 /* PAYLOAD_TYPE.INIT */;
        }
        if (chunkIdx === chunkNum) {
            payloadType = 2 /* PAYLOAD_TYPE.LAST */;
        }
        return await this.transport
            .send(this.cla, 147 /* INS.ALLOWLIST_UPLOAD */, payloadType, 0, chunk, [36864 /* ERROR_CODE.NoError */])
            .then((response) => {
            const errorCodeData = response.subarray(-2);
            const returnCode = errorCodeData[0] * 256 + errorCodeData[1];
            const errorMessage = (0, common_1.errorCodeToString)(returnCode);
            return {
                return_code: returnCode,
                error_message: errorMessage,
            };
        }, common_1.processErrorResponse);
    }
    async uploadAllowlist(message) {
        const chunks = [];
        chunks.push(Buffer.from([0]));
        chunks.push(...SubstrateApp.GetChunks(message));
        return await this.uploadSendChunk(1, chunks.length, chunks[0]).then(async (result) => {
            if (result.return_code !== 36864 /* ERROR_CODE.NoError */) {
                return {
                    return_code: result.return_code,
                    error_message: result.error_message,
                };
            }
            for (let i = 1; i < chunks.length; i += 1) {
                // eslint-disable-next-line no-await-in-loop,no-param-reassign
                result = await this.uploadSendChunk(1 + i, chunks.length, chunks[i]);
                if (result.return_code !== 36864 /* ERROR_CODE.NoError */) {
                    break;
                }
            }
            return {
                return_code: result.return_code,
                error_message: result.error_message,
            };
        }, common_1.processErrorResponse);
    }
}
exports.SubstrateApp = SubstrateApp;
//# sourceMappingURL=substrate_app.js.map